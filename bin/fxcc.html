<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles/styles.css">
  <link rel="stylesheet" href="../styles/fxcc.css">
  <title>FXCC</title>
</head>

<body>
  <div class="heading">
    <div>PC-FXGA Authoring Software</div>
    <div>GMAKER Starter Kit (Ver.1.0)</div>
    <div class="title">Explanation of C Compiler Tools
      <br>(fxcc.exe,fxcp.exe,fxc0.exe,fxc1.exe,fxas.exe:Ver.1.05)
    </div>
    <div class="credits">NEC Home Electronics, Ltd.</div>
    <div class="credits">Nov 10, 1995</div>
    <div class="credits">Translated by Sean Aoki</div>
  </div>

  <a href="../">Return</a>
  <div class="contents">
    <h2>Contents</h2>
    <div class="contents-chapter">
      <div class="contents-head"><a href="#ch1">Chapter 1: C Compiler Information</a></div>
    </div>
    <div class="contents-chapter">
      <div class="contents-head"><a href="#ch2">Chapter 2: Warnings</a></div>
      <div class="contents-subsection"><a href="#ch2-1">2.1: Warnings</a></div>
    </div>
    <div class="contents-chapter">
      <div class="contents-head"><a href="#ch3">Chapter 3: How the C Compiler Works</a></div>
    </div>
    <div class="contents-chapter">
      <div class="contents-head"><a href="#ch4">Chapter 4: C Compiler Processing</a></div>
      <div class="contents-subsection"><a href="#ch4-1">4.1: Preprocessor</a></div>
      <div class="contents-subsection"><a href="#ch4-2">4.2: Parser</a></div>
      <div class="contents-subsection"><a href="#ch4-3">4.3: Global Code Optimizer</a></div>
      <div class="contents-subsection"><a href="#ch4-4">4.4: Code Creator</a></div>
      <div class="contents-subsection"><a href="#ch4-5">4.5: Local Code Optimizer</a></div>
      <div class="contents-subsection"><a href="#ch4-6">4.6: Processing Flow</a></div>
    </div>
    <div class="contents-chapter">
      <div class="contents-head"><a href="#ch5">Chapter 5: How Registers are Used</a></div>
    </div>
    <div class="contents-chapter">
      <div class="contents-head"><a href="#ch6">Chapter 6: Language Specifications</a></div>
      <div class="contents-subsection"><a href="#ch6-1">6.1: Preprocessor Commands</a></div>
      <div class="contents-subsection"><a href="#ch6-2">6.2: Types of Data</a></div>
      <div class="contents-subsection"><a href="#ch6-3">6.3: Type Conversion</a></div>
      <div class="contents-subsection"><a href="#ch6-4">6.4: Special Specifications</a></div>
      <div class="contents-subsubsection"><a href="#ch6-4-1">6.4.1: Setting a Register Use Limit</a></div>
      <div class="contents-subsubsection"><a href="#ch6-4-2">6.4.2: Variable Register Assignment</a></div>
      <div class="contents-subsubsection"><a href="#ch6-4-3">6.4.3: Saving Registers</a></div>
      <div class="contents-subsubsection"><a href="#ch6-4-4">6.4.4: Direct Register Addressing</a></div>
      <div class="contents-subsubsection"><a href="#ch6-4-5">6.4.5: I/O Port Access Syntax</a></div>
      <div class="contents-subsubsection"><a href="#ch6-4-6">6.4.6: Interrupt Functions</a></div>
      <div class="contents-subsubsection"><a href="#ch6-4-7">6.4.7: zero Storage Class Modifiers</a></div>
      <div class="contents-subsubsection"><a href="#ch6-4-8">6.4.8: near Storage Class Modifiers</a></div>
      <div class="contents-subsubsection"><a href="#ch6-4-9">6.4.9: far Storage Class Modifiers</a></div>
      <div class="contents-subsubsection"><a href="#ch6-4-10">6.4.10: About near Type (GP register relative) Symbols</a></div>
    </div>
    <div class="contents-chapter">
      <div class="contents-head"><a href="#ch7">Chapter 7: Using the C Compiler</a></div>
      <div class="contents-subsection"><a href="#ch7-1">7.1: Entering Commands</a></div>
      <div class="contents-subsection"><a href="#ch7-2">7.2: Command Syntax</a></div>
    </div>
    <div class="contents-chapter">
      <div class="contents-head"><a href="#ch8">Chapter 8: Error/Warning Messages</a></div>
      <div class="contents-subsection"><a href="#ch8-1">8.1: Fatal Errors</a></div>
      <div class="contents-subsection"><a href="#ch8-2">8.2: Errors</a></div>
      <div class="contents-subsection"><a href="#ch8-3">8.3: Warnings</a></div>
    </div>
  </div>

  <div class="chapter" id="ch1">
    <h2>Chapter 1 Compiler Information</h2>
    <p>This compiler reads programs written in the C language and generates
      commands for the V810.
    </p>
    <p>Also, while this compiler follows the ANSI standards, it also supports special
      syntax that are not specified in the C language.
    </p>
    <p>Reference:<br>
      <em>C Programming Language, 2nd Edition</em><br>
      B.W. Kernighan/D.M. Ritchie (Japanese Edition translated by Haruhisa Ishida)<br>
      Pearson (Japanese Edition Published by Kyouritsu Publishing)
    </p>
  </div>

  <hr>

  <div class="chapter" id="ch2">
    <h2>Chapter 2</h2>
    <div class="section" id="ch2-1">
      <h3>2.1 Warnings</h3>
      <p>This compiler provides _STARTUP.O as a startup routine to reset the stack point and gp Register values.</p>
      <p>When using this compiler to develop, always link the specified _STARTUP.O.</p>
      <p>Normally in C, when global and static variables defined outside a function don't have a clear initial value,
        it is guaranteed to be reset to 0, but, because of the system structure,
        programs that assume they are reset to 0 and when creating something that explicitly
        resets these, the program itself must reset the variable region so caution is needed.
      </p>
    </div>
  </div>

  <hr>

  <div class="chapter" id="ch3">
    <h2>Chapter 3: How the C Compiler Works</h2>
    <p>The C Compiler evaluates the specified file name switch (evaluates the extension),
      and compiles while controlling each phase.
    </p>
    <p>Depending on the specified file name, it does not perform
      compilation, but instead starts the assembler (FXAS.EXE) and linker (FXLK.EXE)
      to generate an object file and executable file.
    </p>
    <p>There are 4 file types that can be specified, and each performs the following
      actions (assuming no switches are added).
    </p>
    <table>
      <tr>
        <td>C Source File (.c)</td>
        <td>tCompiles, assembles, and links to generate an execubatle file.</td>
      </tr>
      <tr>
        <td>Assembler Source File (.s)<span
            title="Requires an assembler. Note GMAKER Starter Kit does not support an assembler."
            class="underline">*</span></td>
        <td>Assembles and links to generate an executable file.</td>
      </tr>
      <tr>
        <td>Object File (.o)</td>
        <td>Only links, and generates an executable file.</td>
      </tr>
      <tr>
        <td>Archive File (.a)</td>
        <td>Specified as a library file when linking.</td>
      </tr>
    </table>
  </div>

  <hr>

  <div class="chapter" id="ch4">
    <h2>Chapter 4 C Compiler Processing</h2>
    <p>The C Compiler separates its processing into 4 phases: preprocessing, parsing,
      code creating, code optimizing.
    </p>
    <p>The following executables, controlled by the CC Drive executable, perform the above
      operations.
    </p>
    <table>
      <tr>
        <td>1. FXCC.EXE</td>
        <td>CC Driver</td>
      </tr>
      <tr>
        <td>2. FXCP.EXE</td>
        <td>Preprocessor</td>
      </tr>
      <tr>
        <td>3. FXC0.EXE</td>
        <td>Parser, Global Code Optimizer, Code Creator</td>
      </tr>
      <tr>
        <td>4. FXC1.EXE</td>
        <td>Local Code Optimizer</td>
      </tr>
    </table>
    <div class="section" id="ch4-1">
      <h3>4.1 Preprocessor</h3>
      <p>Expands specified include files, replaces macros, and analyzes
        preprocessor commands to output information required for parsing as a
        preprocessor file (.p).
      </p>
      <p>Furthermore, it performs error checking for errors that can be caught at
        the preprocessing level, such as ensuring macros have no mistakes.
      </p>
    </div>
    <div class="section" id="ch4-2">
      <h3>4.2 Parser</h3>
      <p>Reads the preprocessor file and checks syntax. If there are errors or things
        that require reporting, it successively outputs a corresponding message
        and generates information required for code generation. In this case,
        parsing is continued until it finishes reading the preprocessor file.
      </p>
    </div>
    <div class="section" id="ch4-3">
      <h3>4.3 Global Code Optimizer</h3>
      <p>References the information generated by the parser to perform global
        optimization at the C level (converting/editing information)
      </p>
      <p>Once it is finished, the edited information is handed to the code creator
        to generate the code.
      </p>
    </div>
    <div class="section" id="ch4-4">
      <h3>4.4 Code Creator</h3>
      <p>References the information generated by the parser and outputs an intermediate
        file for the local code optimizer (fxc1)
      </p>
    </div>
    <div class="section" id="ch4-5">
      <h3>4.5 Local Code Optimizer</h3>
      <p>Reads the intermediate file generated by the code creator and performs
        assembly-level optimization (shortening commands, loading registers, reducing stores)
      </p>
      <p>It also optimizes branch-related commands and the pipeline.</p>
      <p>
        Everything but pipeline optimization will be performed even without specifying
        switches. (Default optimize)
      </p>
    </div>
    <div class="section" id="ch4-6">
      <h3>4.6 Processing Flow</h3>
      <div id="table46">
        <div id="table46-start">CC Driver (FXCC.EXE)</div>
        <div class="table46-row">
          <div class="table46-block">Preprocessor (FXCP.EXE)</div>
          <div class="table46-block">test.c<br>test.p</div>
        </div>
        <div class="table46-row">
          <div class="table46-block">Parser</div>
        </div>
        <div class="table46-row">
          <div class="table46-block">Code Creator</div>
        </div>
        <div class="table46-row">
          <div class="table46-block">Global Code Optimizer<br>(FXC0.EXE)</div>
          <div class="table46-block">test.1 [test.2] (when -g is specified)</div>
        </div>
        <div class="table46-row">
          <div class="table46-block">Local Code Optimizer<br>(FXC1.EXE)</div>
          <div class="table46-block">test.s</div>
        </div>
        <div class="table46-row">
          <div class="table46-block">Assembler (FXAS.EXE)</div>
          <div class="table46-block">test.o</div>
        </div>
        <div class="table46-row">
          <div class="table46-block">Linker (FXLK.EXE)</div>
          <div class="table46-block">test.ex</div>
        </div>
      </div>
    </div>

    <hr>

    <div class="chapter" id="ch5">
      <h2>Chapter 5 How Registers are Used</h2>
      <table id="register-table">
        <tr>
          <th>Register</th>
          <th>Name</th>
          <th>Explanation</th>
        </tr>
        <tr>
          <td>zero</td>
          <td>Zero Register</td>
          <td>Holds the value 0</td>
        </tr>
        <tr>
          <td>at</td>
          <td>Assemelber Reserved Register</td>
          <td>Used when commands are expanded by the assembler</td>
        </tr>
        <tr>
          <td>hsp</td>
          <td>Handler Stack Pointer</td>
          <td>Currently unused</td>
        </tr>
        <tr>
          <td>sp</td>
          <td>Stack Pointer</td>
          <td>Holds the address of the stack frame</td>
        </tr>
        <tr>
          <td>gp</td>
          <td>Global Pointer</td>
          <td>Sets the base register when accessing the near symbol</td>
        </tr>
        <tr>
          <td>tp</td>
          <td>Text Pointer</td>
          <td>Currently Unused</td>
        </tr>
        <tr>
          <td>ra0-ra3</td>
          <td>Function Argument Register</td>
          <td>Used to pass arguments</td>
        </tr>
        <tr>
          <td>rg0-rg9</td>
          <td>Operation Registers</td>
          <td>Used when performing operations<br>(The return value sets rg0)</td>
        </tr>
        <tr>
          <td>rs0-rs9</td>
          <td>Register Variable Registers</td>
          <td>Used for symbols that declare register use</td>
        </tr>
        <tr>
          <td>ut</td>
          <td>Operation Register for Commands</td>
          <td>Set by remainder in division</td>
        </tr>
        <tr>
          <td>link</td>
          <td>Link Register</td>
          <td>Holds the return address for the function</td>
        </tr>
      </table>
      <p>rs6-ut are reserved when using bit string commands</p>
    </div>

    <div class="chapter" id="ch6">
      <h2>Chapter 6 Language Specifications</h2>
      <div class="section" id="ch6-1">
        <h3>6.1 Preprocessor Commands</h3>
        The following commands are available
        <ol>
          <li>
            <p>Defining Macros</p>
            <div class="codeblock">#define MacroName [Token]

#define MacroName (arg1,arg2,...) Token
#undef MacroName</div>
          </li>
          <li>
            <p>Including Source Files</p>
            <div class="codeblock">#include &lt;File Name&gt; or "File Name"</File></div>
          </li>
          <li>
            <p>Conditional Compilation</p>
            <div class="codeblock">#if Expression

#ifdef MacroName

#ifndef MacroName
#else
#endif
#elif Expression</div>
          </li>
          <li>
            <p>Other Control Commands</p>
            <div class="codeblock">#line Constant ["File Name"]
#error ErrorMessage
#pragma
#asm
#endasm</div>
          </li>
        </ol>
        <details>
          <summary>About #pragma</summary>
          <div class="summary-contents">
            Supports special commands dependent on the compiler:
            <div class="codeblock">#pragma align(??)
#pragma optimize( ?? -? )
#pragma defseg( -? , ?? )
#pragma seg(??)</div>
              <h3>Function Definition Alignment</h3>
              <p>Syntax</p>
              <div class="codeblock">#pragma align (Alignment size)</div>
              <p>Only the first function found that is defined after the above statement is affected.</p>
              <div class="codeblock">#pragma align ( 8 ) → Binary
#pragma align ( 0x10 ) → Hexadecimal
#pragma align ( 04 ) → Octal</div>
              <p>Don't forget to start with 0 when specifying octal.</p>
              <h3>Control Optimization</h3>
              <p>Syntax</p>
              <div class="codeblock">#pragma optimize (On/Off Switch  Selection Switch)</div>
              <p>
                On/Off Switch:<br>
                &emsp;on &emsp;→ Optimize<br>
                &emsp;off&emsp;→ Don't Optimize<br></p>
              <p>
                Selection Switch:<br>
                &emsp;-c &emsp;→ Copy Propagation<br>
                &emsp;-d &emsp;→ Dead Code Elimination<br>
                &emsp;-p &emsp;→ Pipeline Optimization<br>
                &emsp;-r &emsp;→ Register Assignment<br>
                &emsp;-s &emsp;→ Common Subexpression Elimination<br>
                &emsp;-v &emsp;→ Dead Variable Elimination</p>
              <p>In general, the range of effect starts from the line this statement
                is given until either the file ends or another statement changing the on/off state is given,
                but if -r or -v is given in a function, the variables within the function are affected.
              </p>
              <p>Note that other than -s and -v, #pragma optimize( ?? -? ) is only
                effective when -O (compiler optimization option) is set
              </p>
              <p>Example:</p>
              <div class="codeblock">#pragma optimize ( off -c ) →Don't propagate statement copying
#pragma optimize ( off -d ) →Don't eliminate dead code
#pragma optimize ( on  -p ) →Perform pipeline optimization
#pragma optimize ( on  -r ) →Assign auto variables and function arguments to registers
#pragma optimize ( off -s ) →Don't eliminate common subexpressions
#pragma optimize ( on  -v ) →Delete unused auto/register variables</div>
              <p>Program Example:</p>
              <div class="codeblock">--------- sample.c ---------
main()
{
    int a,b,c;
    a = 1;
#pragma optimize (off -d)        →From this line forward, don't delete dead code
    b = 2;
#pragma optimize (on -d )        →Start eliminating dead code again
    c = 3;
}
-----
% fxcc -S -O sample.c
--------- sample.s --------- *
#
    file    "sample.c"
    seg     cseg
#
    globl   main
    seg     cseg
main:
    add     #$fffffffc, sp
# line 7
    mov     #$2, rg0             →From the previous specification, b=2 is not deleted
    st.w    rg0, $0(sp)
    add     #$4, sp
    rts
#
    seg     cseg
------</div>
            <h3>Defining Segments</h3>
            <p>Syntax</p>
            <div class="codeblock">#pragma defseg (Option switch, Segment name)</div>
            <p>Option switches:<br>
              &emsp;-C&emsp;→Specify code segment<br>
              &emsp;-D&emsp;→Specify data segment<br>
              &emsp;-B&emsp;→Specify BSS segment<br>
              &emsp;-d&emsp;→Specify GP relative data segment<br>
              &emsp;-b&emsp;→Specify GP relative BSS segment<br>
              &emsp;-Z&emsp;→Specify zero page segment</p>
            <p>Segment name:<br>
              &emsp;????&emsp;→Use defined segment name</p>
            <p>Example:</p>
            <div class="codeblock">#pragma defseg(-C,Text)&emsp;→Define Text
#pragma defseg(-D,Data)   →Define Data
#pragma defseg(-B,Bss)    →Define Bss
#pragma defseg(-d,Gdata)  →Define Gdata
#pragma defseg(-b,Gbss)   →Define Gbss
#pragma defseg(-Z,Zero)   →Define Zero</div>
            <h3>Switching Segments</h3>
            <p>Syntax</p>
            <div class="codeblock">#pragma seg (Segment name)</div>
            <p>Segment name:<br>
              &emsp;???? &emsp;→Switch to a user defined segment<br>
              &emsp;cseg &emsp;→Switch to the default code segment<br>
              &emsp;dseg &emsp;→Switch to the default data segment<br>
              &emsp;bseg &emsp;→Switch to the default BSS segment<br>
              &emsp;gdseg&emsp;→Switch to the default GP relative data segment<br>
              &emsp;gbseg&emsp;→Switch to the default GP relative BSS segment<br>
              &emsp;zseg &emsp;→Switch to the zero page segment</p>
            <p>Example:</p>  
            <div class="codeblock">#pragma seg(Text) &emsp;→Switch to Text
#pragma seg(Data)  →Switch to Data
#pragma seg(Bss)   →Switch to Bss
#pragma seg(Gdata) →Switch to Gdata
#pragma seg(Gbss)  →Switch to Gbss
#pragma seg(Zero)  →Switch to Zero</div>
            <p>Program Example:</p>
            <div class="codeblock">--------- sample.c ---------

#pragma defseg(-C,Text)  →Define a code segment called Text
#pragma defseg(-D,Data)  →Define a data segment called Data
#pragma defseg(-B,Bss)   →Define a BSS segment called Bss
#pragma defseg(-d,Gdata) →Define a GP relative data segment called Gdata
#pragma defseg(-b,Gbss)  →Define a GP relative BSS segment called Gbss
#pragma defseg(-Z,Zero)  →Define a zero page segment called Zero

#pragma seg(Text)        →Change code segment name to Text
#pragma seg(Data)        →Change data segment name to Data
#pragma seg(Bss)         →Change BSS segment name to Bss
#pragma seg(Gdata)       →Change GP relative data segment to Gdata
#pragma seg(Gbss)        →Change GP relative BSS segment to Gbss
#pragma seg(Zero)        →Change zero page segment name to Zero

int Ea=1;                →Assign to Data
int Eb;                  →Assign to Bss
zero int Eza;            →Assign to Zero
near int Ena = 1;        →Assign to Gdata
near int Enb;            →Assign to Gbss
void foo()               →Assign to Text
{
}

#pragma seg(cseg)        →Change code segment name to default
#pragma seg(dseg)        →Change data segment name to default
#pragma seg(bseg)        →Change BSS segment name to default
#pragma seg(gdseg)       →Change GP relative data segment name to default
#pragma seg(gbseg)       →Change GP relative BSS segment name to default
#pragma seg(zseg)        →Change Zero page segment name to default

int Ea1=1;               →Assign to dseg
int Eb1;                 →Assign to bseg
zero int Eza1;           →Assign to zseg
near int Ena1 = 1;       →Assign to gdseg
near int Enb1;           →Assign to gbseg
void foo1()              →Assign to cseg
{
}
------
% fxcc -S sample.c
--------- sample.s --------- *
#
defseg    Text,"text"
defseg    Data,"data"
    defseg    Bss,"bss"
    defseg    Gdata,"data,offset"
    defseg    Gbss,"bss,offset"
    defseg    Zero,"bss,zero"
    file      "sample.c"
    seg       Data
    globl     Ea
Ea:
    dw        $1
    seg       Gdata
    globl     Ena
Ena:
    dw        $1
    seg       dseg
    globl     Ea1
Ea1:
    dw        $1
    seg       gdseg
    globl     Ena1
En1:
    dw        $1
    seg       Gbss
    globl     Enb
Enb:
    ds        $4
    seg       gbseg
    globl     Enb1
Enb1:
    ds        $4
    seg       Bss
    globl     Eb
Eb:
    ds        $4
    seg       bseg
    globl     Eb1
Eb1:
    ds        $4
    seg       Zero
    globl     Eza
Eza:
    ds        $4
    seg       zseg
    globl     Eza1
Eza1:
    ds        $4
#
    globl     foo
    seg       Text
foo:
    rts
    #
    globl     foo1
    seg       cseg
foo1:
    rts
#
    seg       cseg
------</div>
          </div>
        </details>
        <details>
          <summary>About #asm, #endasm</summary>
          <div class="summary-contents">
            Write assembly code directly in the C program. Written as
            <div class="codeblock">#asm
:
:
Assembler Code
#endasm</div>
            <p>Everything from the line after #asm to #endasm is not edited and outputted as assembler source code.</p>
            <p>Example:</p>
            <div class="codeblock">--------- adp_data.c ---------
#asm
    seg   dseg
    align $4
adp_data::
    binload "SAMPLE.ADP",0x2c
#endasm

* binload "File name"[, offset[, number of bytes]]</div>
          </div>
        </details>
      </div>
      <div class="section" id="ch6-2">
        <h3>6.2 Types of Data</h3>
        <p>Data types can be defined in many ways with storage class specifiers and
          type specifiers.
        </p>
        <ol>
          <li>
            Storage class specifiers
            <p>auto, register, static, extern, typedef</p>
            <p>The above is the same as the standard C language specification, but the fxcc compiler also
              has interrupt, zero, near, far as modifiers.
            </p>
            <h4>interrupt</h4>
            <p>Used when defining an interrupt type function (anything other than a function type throws an error)</p>
            <p>Normally, functions are generated with the rts command at the end, but with this is specified, it is generated
              with the reti commend. Saving registers and other processes required for an interrupt must be performed by the user.
            </p>
            <h4>zero</h4>
            <p>Means the symbol is a zero register relative symbol. The zero register relative symbol accesses
              the zero register + signed 16 bit offset.
            </p>
            <h4>near</h4>
            <p>Means the symbol is a GP register relative symbol.
              Accessed in 32 bits when the symbol is loaded. Used to explicitly declare a symbol
              accessed in 32 bits.
            </p>
          </li>
          <li>
            Type specifiers
            <p>void, char, short, int, long, float</p>
            <p>double (currently unsupported)</p>
            <p>signed, unsigned, struct, union, enum</p>
            <p>const, volatile</p>
            <p>Symbol declared with typedef</p>
          </li>
        </ol>
      </div>
      <div class="section" id="ch6-3">
        <h3>6.3 Type Conversion</h3>
        <p>When the two sides of a substitution, evaluation, or comparison are different, a type conversion occurs.</p>
        <p>The conversion method follows the ANSI standard, with evaluation and comparison always converting to int,
          and substitution converted to the type that is being substituted.
        </p>
      </div>
      <div class="section" id="ch6-4">
        <h3>6.4 Special Specifications</h3>
        <div class="subsection" id="ch6-4-1">
          <h4>6.4.1 Restricting Register Use</h4>
          <p>Code is generated without using the specified register.</p>
          <p>Specified with: regmsk &lt;register&gt;;</p>
          <p>The only registers that can be specified are operation registers and register variable registers.</p>
          <p>NEC Register format can be used.</p>
          <p>Operation registers: rg1 - rg9 : r11 - r19</p>
          <p>Register variable registers: rs0 - rs9 : r20 - r29</p>
          <div class="codeblock">regmsk rs2                  → rs2 not allowed
regmsk rs2, rg1, rg2;       → rs2, rg1, rg2 not allowed
regmsk rs2-rs6;             → rs2, rs3, rs4, rs5, rs6 not allowed</div>
          </div>
          <p>',' and '-' can be used together. In addition, the specified register names must be lowercase</p>
          <div class="codeblock">regmsk rg2, rg5-rg7, rg9, rs1;</div>
          <p>Furthermore, regmsk is treated similarly to a variable declaration, and can be specified within each block. (Cannot specify in the middle of an expression)</p>
          <p>Example:</p>
          <div class="codeblock">test.c

regmsk rs0-rs2;   → In this file, rs0 to rs2 cannot be used

void fnc(int arg)
{
    regmsk rg2;           → In this function, rs0 to rs2 and rg2 cannot be used.
    if ( arg ) {
        regmsk rg3,rg6;   → In this block, rs0 to rs2, rg2, rg3, rg6 cannot be used.
    }
}</div>
          <p>The following registers cannot be specified (will be ignored):</p>
          <table>
            <tr>
              <td>zero</td>
              <td>Zero Register</td>
            </tr>
            <tr>
              <td>at</td>
              <td>Assembler Reserved</td>
            </tr>
            <tr>
              <td>hsp</td>
              <td>Handler Stack Pointer</td>
            </tr>
            <tr>
              <td>sp</td>
              <td>Stack Pointer</td>
            </tr>
            <tr>
              <td>gp</td>
              <td>gp Register</td>
            </tr>
            <tr>
              <td>ra0-ra3</td>
              <td>Function Parameters</td>
            </tr>
            <tr>
              <td>rg0</td>
              <td>Function Return Value Register</td>
            </tr>
            <tr>
              <td>ut</td>
              <td>Special Operation Register</td>
            </tr>
            <tr>
              <td>link</td>
              <td>Link Register</td>
            </tr>
          </table>
        <div class="subsection" id="ch6-4-2">
          <h4>6.4.2 Variable Register Assignment</h4>
          <p>A given register can be used as a variable</p>
          <p>Specified with:</p>
          <div class="codeblock">int a:rg8;</div>
          <div class="codeblock">register int a:rg8;</div>
          <p>The second case assigns the rg8 register without using the register variable registers.</p>
          <div class="codeblock">int a:rg8,b:rg8;</div>
          <p>Results in a duplication error.</p>
          <p>Registers must be specified with lowercase characters.</p>
          <p>Example:</p>
          <div class="codeblock">foo()
{
    int a:rg8;
    
    a = 0;
}               → Treats a as rg8</div>
          <p>In an expanded register syntax like int a:rg8;, the storage class will always be register.</p>
          <div class="codeblock">bar()
{
    extern int a:rg8;   → register int a:rg8;
    static int b:rg1;   → register int b:rg1;
    int c:rg2;          → register int c:rg2;
}

    int e:rg3;          → register int e:rg3;   → error</div>
          <p>An error is thrown because a register was declared with an external linkage.</p>
        </div>
        <div class="subsection" id="ch6-4-3">
          <h4>6.4.3 Saving Registers</h4>
          <p>Save a given register at the start of a function or block. (Reverts it back at the end of the function or block)</p>
          <p>Specified with: regsave &lt;register&gt;;</p>
          <p>Registers are specified the same way as regmsk</p>
          <p>Register names must be specified in lowercase characters.</p>
        </div>
        <div class="subsection" id="ch6-4-4">
          <h4>6.4.4 Direct Register Addressing</h4>
          <p>The following registers can be directly written into the C program:</p>
          <p>General Registers:</p>
          <table>
            <tr>
              <td>This System's</td>
              <td>Format</td>
              <td>NEC's</td>
              <td>Format</td>
            </tr>
            <tr>
              <td>zero</td>
              <td>_ZERO</td>
              <td>r0</td>
              <td>_R0</td>
            </tr>
            <tr>
              <td>at</td>
              <td>_AT</td>
              <td>r1</td>
              <td>_R1</td>
            </tr>
            <tr>
              <td>hsp</td>
              <td>_HSP</td>
              <td>r2</td>
              <td>_R2</td>
            </tr>
            <tr>
              <td>sp</td>
              <td>_SP</td>
              <td>r3</td>
              <td>_R3</td>
            </tr>
            <tr>
              <td>gp</td>
              <td>_GP</td>
              <td>r4</td>
              <td>_R4</td>
            </tr>
            <tr>
              <td>tp</td>
              <td>_TP</td>
              <td>r5</td>
              <td>_R5</td>
            </tr>
            <tr>
              <td>ra0-ra3</td>
              <td>_RA0-_RA3</td>
              <td>r6-r9</td>
              <td>_R6-_R9</td>
            </tr>
            <tr>
              <td>rg0-rg9</td>
              <td>_RG0-_RG9</td>
              <td>r10-r19</td>
              <td>_R10-_R19</td>
            </tr>
            <tr>
              <td>rs0-rs9</td>
              <td>_RS0-_RS9</td>
              <td>r20-r29</td>
              <td>_R20-_R29</td>
            </tr>
            <tr>
              <td>ut</td>
              <td>_UT</td>
              <td>r30</td>
              <td>R30</td>
            </tr>
            <tr>
              <td>link</td>
              <td>_LINK</td>
              <td>r31</td>
              <td>R31</td>
            </tr>
          </table>
          <p>Special Registers:</p>
          <table>
            <tr>
              <td>eipc</td>
              <td>_EIPC</td>
            </tr>
            <tr>
              <td>eipsw</td>
              <td>_EIPSW</td>
            </tr>
            <tr>
              <td>fepc</td>
              <td>_FEPC</td>
            </tr>
            <tr>
              <td>fepsw</td>
              <td>_FEPSW</td>
            </tr>
            <tr>
              <td>ecr</td>
              <td>_ECR</td>
            </tr>
            <tr>
              <td>psw</td>
              <td>_PSW</td>
            </tr>
            <tr>
              <td>pir</td>
              <td>_PIR</td>
            </tr>
            <tr>
              <td>tkcw</td>
              <td>_TKCW</td>
            </tr>
            <tr>
              <td>chcw</td>
              <td>_CHCW</td>
            </tr>
            <tr>
              <td>adtre</td>
              <td>_ADTRE</td>
            </tr>
          </table>
        </div>
        <div class="subsection" id="ch6-4-5">
          <h4>6.4.5 I/O Port Access Syntax</h4>
          <p>Special function calls are used to access the I/O port from the C program.</p>
          <table>
            <tr>
              <td></td>
              <td>Syntax</td>
              <td>Generated Code</td>
            </tr>
            <tr>
              <td>Input</td>
              <td>_INPORTB(value)</td>
              <td>in.b value(zero), reg</td>
            </tr>
            <tr>
              <td></td>
              <td>_INPORTH(value)</td>
              <td>in.h value(zero), reg</td>
            </tr>
            <tr>
              <td></td>
              <td>_INPORTW(value)</td>
              <td>in.w value(zero), reg</td>
            </tr>
            <tr>
              <td>Output</td>
              <td>_OUTPORTB(value, data)</td>
              <td>data → reg<br>out.b reg,value(zero)</td>
            </tr>
            <tr>
              <td></td>
              <td>_OUTPORTH(value, data)</td>
              <td>data → reg<br>out.h reg,value(zero)</td>
            </tr>
            <tr>
              <td></td>
              <td>_OUTPORTW(value, data)</td>
              <td>data → reg<br>out.w reg,value(zero)</td>
            </tr>
          </table>
          <p>These functions are registered as reserved names, so you can not declare variables/functions with the same name.</p>
        </div>
        <div class="subsection" id="ch6-4-6">
          <h4>6.4.6 Interruprt Functions</h4>
          <p>By using the interrupt expansion keyword, you can write an interrupt handler routine.
            Interrupt functions must be declared without a return value (void) and return with reti instead of rts.
            Saving and reverting registers must be done by the user with regsave.
          </p>
          <div class="codeblock">void    interrupt   functionName()
{
     function body
}</div>
        </div>
        <div class="subsection" id="ch6-4-7">
          <h4>6.4.7 zero Storage Class Modifier</h4>
          <p>The zero keyword is used to declare a zero register relative symbol.
            A zero register relative symbol loads from memory based on an offset from the zero register.
          </p>
          <p>Written as: &lt;Storage class specifier&gt; zero &lt;type specifier&gt; &lt;symbol name&gt;</p>
          <p>Example:</p>
          <div class="codeblock">--------- ok.c ---------
zero int          Eza;
static zero int   Ezb;
extern zero int   Ezc;
void foo()
{
    static zero int za;
    extern zero int zb;
    zb =Eza;
}
--------- ok.s --------- *
#
    file    "ok.c"
    seg     zseg
@L2:
    ds      $4
    zglobl  Ezc     → Outside reference zero page symbol</div>
    zglobl  zb      → Outside reference zero page symbol
    seg     zseg
    globl   Eza
Eza:                → Since it is a zero page symbol, it is assigned to zseg
    ds      $4
Ezb:                → Since it is a zero page symbol, it is assigned to zseg
    ds      $4
    align   $4
#
    globl   foo
    seg     cseg
foo:
# line 10
    ld.w    Eza(zero),rg0    → Accessed relative to zero register
    st.w    rg0,zb(zero)     → Accessed relative to zero register
    rts
#
    seg     cseg

--------- err.c ---------
zero int    Ezx = 1;    → Resetting causes an error
zero void   bar()       → Using in a function causes an error
{
    zero int    zx;     → Defining a zero page symbol within a function that has an external linkage causes an error.
}</div>
        <div class="subsection" id="ch6-4-8">
          <h4>6.4.8 near Storage Class Modifier</h4>
          <p>The near keyword is used to declare a GP register relative symbol.
            A GP register relative symbol loads from memory based on an offset from the gp register.</p>
          <p>Written as &lt;Storage class specifier&gt; near &lt;type specifier&gt; &lt;symbol name&gt;</p>            
          <p>Example:</p>
          <div class="codeblock">--------- ok.c ---------
near int          Ena;
static near int   Enb;
extern near int   Enc;
void foo()
{
    static near int   na;
    extern near int   nb;
    nb = Ena;
}
--------- ok.s ---------
#
    file        "ok.c"
    seg         gbseg
@L2:
    ds          $4
    zglobl[gp]  Enc         → Outside reference GP relative symbol
    zglobl[gp]  nb          → Outside reference GP relative symbol
    seg         gbseg
    align       $4
    globl       Ena
Ena:                        → Since it is a GP relative BSS symbol, it is assigned gbseg
    ds          $4
Enb:                        → Since it is a GP relative BSS symbol, it is assigned gbseg
    ds          $4
    align       $4
#
    globl       foo
    seg         cseg
foo:
# line 10
    ld.w        Ena(gp),rg0 → Accessed relative to the GP register
    st.w        rg0,nb(gp)  → ACcessed relative to the GP register
    rts
#
    seg         cseg
--------- err.c ---------
near void   bar()           → Using in a function causes an error
{
    near int    nx;         → Defining a GP relative symbol within a function that has an external linkage causes an error.
}</div>
        </div>
        <div class="subsection" id="ch6-4-9">
          <h4>6.4.9 far Storage Class Modifier</h4>
          <p>Used to explicitly declare a 32-bit absolute symbol when the -x switch
            (switch that makes global variables GP relative symbols by default) is specified.
          </p>
          <p>Written as &lt;Storage class specifier&gt; far &lt;type specifier&gt; &lt;symbol name&gt;</p>
          <p>Example:</p>
          <div class="codeblock">--------- ok.c ---------
far int E1;
int     E2;

void    foo()
{
    E1 = 0;
    E2 = 0;
}
---------
% fxcc -x -S ok.c
--------- ok.s ---------
#
    file    "z.c"
    seg     bseg
    align   $4
    globl   E1
E1:                   → Because it is declared far, it is a 32 bit symbol.
    ds      $4
    seg     gbseg
    align   $4
    globl   E2
E2:                   → Becomes GP relative because of the -x switch
    ds      $4
#
    globl   foo
    seg     cseg
foo:
# line 6
    movhi   #hi1(E1),zero,rg1     → Accessed as a 32 bit symbol
    st.w    zero,lo(E1)(rg1)
# line 7
    st.w    zero,E2(gp)           → GP Register relative address
#
    rts
#
    seg     cseg
--------- err.c ---------
far void    bar()                 → Throws an error when used for a function
{
    far     int   fx;             → Throws an error when defining a symbol that has an external linkage within a function
}</div>
        </div>
        <div class="subsection" id="ch6-4-10">
          <h4>6.4.10 About near Type (GP relative register) Symbols</h4>
          <p>This compiler supports using GP relative register using the near keyword.
            By how the system works, variables with the near type are assigned the gbseg segment.
            When you access memory relative to a register, the displacement is 16 bit, so the area that can be
            accessed is -32768 to +32767 from the address designated gp. Variables declared with near must
            be within this range. (The near variable area cannot exceed 64K bytes in total.)
          </p>
          <p><strong>About resetting the gp register</strong><br>
            If a segment is not explcitly specified, this compiler takes an unreset symbol
            declared with the near keyword and assigns it to gbseg, but to ensure this symbol is
            correctly accessed, the _Sgbseg value is usually set in the startup routine. (Set in _STARTUP.O)
          </p>
          <p>Example:</p>
          <div class="codeblock">---- _start.s ---- *
        ・
        ・
        ・
  mov.w   #_Sgbseg
        ・
        ・
        ・
   jmp     main</div>
          <p><strong>About declaring variables</strong><br>
            The near storage class modifier can only be used on external variables declared outside of functions
            and extern and static variables inside and outside functions. For the specifics on how to declare variables, see the example below.
          </p>
          <p>Example:</p>
          <div class="codeblock">--------- main.c ---------
extern        char    foo1;
extern        char    foo2;

        near  long    Data;
extern  near  char    bar1;
static  near  int     Flg;

main()
{
    extern  near  char  bar2;
    static  near  short Test;
    
    foo2 = foo1;
    bar2 = bar1;
    Test = 0;
    Data = Flg;
}
------------</div>
          <p><strong>About the addresses referenced</strong><br>
            The value of the symbol used when referencing address is normally the first
            address of the segment the symbol belongs to (e.g. _Sbseg) plus an offset. However, with a near keyword symbol,
            because it is used relative to a register, the symbol's value is used as the offset.
          </p>
          <div style="display: flex;">
            <div class="codeblock" style="width: 50%;">Regular external symbol
--------- foo.c ---------
char foo1;
char foo2;

--------- foo.s ---------
        seg       bseg
        globl     foo1
foo1:
        ds        $1
        globl     foo2
foo2:
        ds        $1
  ・          ・
  ・          ・
  ・          ・   -Sbseg
+0・・・・・←($9000)
  ・  foo1    ・
+1・・・・・
  ・  foo2    ・
  ・・・・・
  ・   ・     ・
  ・   ・     ・
  ・   ・     ・
  ・          ・</div>
            <div class="codeblock" style="width: 50%;">near Symbol
--------- bar.c ---------
near char bar1;
near char bar2;

--------- bar.s ---------
        seg       bseg
        globl     bar1
bar1:
        ds        $1
        globl     bar2
bar2:
        ds        $1
  ・          ・
-32768・・・・・Original
  ・  bar1    ・・ _Sgbseg
-32767・・・・・($10000)
  ・  bar2    ・・
-32766・・・・・
  ・    ・    ・+32768($8000)
  ・    ・    ・・
 0・・・・・・・Actual
  ・          ・ _Sgbseg
  ・          ・ ($18000)</div>
            </div>
            <p>Translator note: I could not figure out if Notepad formatted this correctly,
              so it is possible the format is wrong.
            </p>
            <p>Assuming bseg starts at $9000 and gbseg starts at $10000,</p>
            <table>
              <tr>
                <th>Regular<br>Symbol Name</th>
                <th>Value</th>
                <th>near<br>Symbol Name</th>
                <th>Value</th>
              </tr>
              <tr>
                <td>_Sbseg</td>
                <td>$9000</td>
                <td>_Sgbseg</td>
                <td>$18000</td>
              </tr>
              <tr>
                <td>foo1</td>
                <td>$9000</td>
                <td>bar1</td>
                <td>$8000(-32768)</td>
              </tr>
              <tr>
                <td>foo2</td>
                <td>$9001</td>
                <td>bar2</td>
                <td>$8001(-32767)</td>
              </tr>
            </table>
            <p>is what it becomes.</p>
            <p>Note: _Sbseg,_Sgbseg are special symbols created by the linker.
              These are normally symbols that point to the first address of the segment, but near segments,
              because they are used relative to a register, are treated specially, by adding +32768($8000) to the original address.
            </p>
            <p>The following diagram shows _start.s main.c foo.c bar.c after they are compiled, assembled, and linked.</p>
            <div class="codeblock">    ・            ・
  +0・・・・・・・・←_Sbseg
    ・    foo1    ・
  +1・・・・・・・・
    ・            ・
    ・・・・・・・・
    ・      .     ・
    ・      .     ・
    ・      .     ・
    ・            ・
    ・・・・・・・・-32768  ←・・・・Original
    ・            ・                      ・    _Sgbseg
    ・    Data    ・                      ・
    ・            ・                      ・
    ・            ・                      ・         Symbol Name   Value
    ・・・・・・・・-32764                 ・
    ・            ・                      ・         foo1          _Sbseg+0
    ・            ・                      ・
    ・    Flg     ・                      ・         foo2          _Sbseg+1
    ・            ・                      ・         Data          -32768
    ・・・・・・・・-32760                 ・         Flg           -32764
    ・    Test    ・                      ・         Test(@L2)     -32760
    ・            ・                      ・
    ・・・・・・・・                       ・         bar1          -32756
    ・  (.align)  ・                      ・         bar2          -32755
    ・            ・                      ・
    ・・・・・・・・-32756                 ・
    ・    bar1    ・                      ・
    ・・・・・・・・-32755                 ・
    ・    bar2    ・                      ・
    ・・・・・・・・                       ・
    ・      .     ・                      ・
    ・      .     ・                  +32768($8000)
    ・      .     ・                      ・
    ・            ・                      ・
gp→・・・・・・・・0       ←・・・・Actual
    ・      .     ・                          _Sgbseg
    ・      .     ・
    ・      .     ・
    ・            ・
  
  
main:
# line 13
      movhi   #hi1(foo1),zero,rg1  ;
      ld.b    lo(foo1)(rg1),rg0    ; Normal external variable
      movhi   #hi1(foo2),zero,rg2  ;
      st.b    rg0,lo(foo2)(rg2)    ;
      # line  14
      ld.b    bar1(gp),rg3         ; Becomes ld.b -32756(gp),rg3
      st.b    rg3,bar2(gp)         ; Accesses the desired region
      # line  15
      st.h    zero,@L2(gp)         ; The name changes for static inside a function
      #line   16
      ld.w    Flg(gp),rg5          ;
      st.w    rg5,Data(gp)         ;
      rts</div>
          <p><strong>Warning if you have multiple near type segments</strong><br>
            When a near symbol that was explicitly reset is declared, multiple near type segments exist.
            In cases like that, those segments must be assigned to consecutive regions.
            (This is not applicable when you manipulate the gp register at execution time.)
            When you want assign consecutive regions, specify 
          </p>
          <div class="codeblock">/gdseg + gbseg:nnnn (where nnnn is the address)</div>
          <p>at link time, and set the address of the first segment in the consecutive regions
            for the initial value of the gp register. If the segments are incorrect, they cannot be accessed correctly.
            (_Sgdseg in the case above.)
          </p>
          <div class="codeblock">---- _start.s ---- *
            ・
            ・
            ・
      mov.w   #_Sgdseg,gp
            ・
            ・
            ・
       jmp     main</div>
          <p>Furthermore, the value of the symbol is offset from the first segment, as opposed to the offset
            from the segment the symbol is in, except for the segment used to reset the gp register.
          </p>
        </div>
      </div>
    </div>

    <hr>

    <div class="chapter" id="ch7">
      <h2>Chapter 7 Using the C Compiler</h2>
      <div class="section" id="ch7-1">
        <h3>7.1 </h3>
      </div>
      <div class="section" id="ch7-2">
        <h3>7.2 Command Syntax</h3>
        
      </div>
    </div>

    <div class="chapter" id="ch8">
      <h2>Chapter 8 Error/Warning Messages</h2>
      <div class="section" id="ch8-1">
        <h3>8.1 Fatal Errors</h3>
      </div>
      <div class="section" id="ch8-1">
        <h3>8.2 Errors</h3>
      </div>
      <div class="section" id="ch8-1">
        <h3>8.3 Warnings</h3>
      </div>
    </div>

  </div>

</body>

</html>