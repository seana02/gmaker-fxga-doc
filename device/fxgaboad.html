<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../styles/styles.css">
  <link rel="stylesheet" href="../styles/fxgaboad.css">
  <title>FXGABOAD</title>
</head>

<body>
  <div class="heading">
    <div>PC-FXGA Authoring Software</div>
    <div>GMAKER Starter Kit (Ver.1.0)</div>
    <div class="title">Explanation of Overall PC-FXGA Device
    </div>
    <div class="credits">NEC Home Electronics, Ltd.</div>
    <div class="credits">Nov 10, 1995</div>
    <div class="credits">Translated by Sean Aoki</div>
  </div>

  <a href="../">Return</a>
  <div class="contents">
    <h2>Contents</h2>
    <div class="contents-chapter">
      <div class="contents-head"><a href="#ch1">Chapter 1: Introduction</a></div>
      <div class="contents-subsection"><a href="#ch1-1">1.1: PC-FXGA Board Summary</a></div>
      <div class="contents-subsection"><a href="#ch1-2">1.2: Main Features</a></div>
    </div>
    <div class="contents-chapter">
      <div class="contents-head"><a href="#ch2">Functional Features</a></div>
      <div class="contents-subsection"><a href="#ch2-1">2.1: Address List (Memory Map)</a></div>
      <div class="contents-subsection"><a href="#ch2-2">2.2: I/O Access Space</a></div>
      <div class="contents-subsection"><a href="#ch2-3">2.3: Address List</a></div>
      <div class="contents-subsection"><a href="#ch2-4">2.4: Onboard Register List</a></div>
      <div class="contents-subsection"><a href="#ch2-5">2.5: Keypad Interface</a></div>
      <div class="contents-subsection"><a href="#ch2-6">2.6: Timer</a></div>
      <div class="contents-subsection"><a href="#ch2-7">2.7: Interrupter/Controller</a></div>
      <div class="contents-subsection"><a href="#ch2-8">2.8: Other Onboard Register Features</a></div>
      <div class="contents-subsubsection"><a href="#ch2-8-1">2.8.1: Expansion Bus Reset Register</a></div>
      <div class="contents-subsubsection"><a href="#ch2-8-2">2.8.2: HuC6270 Address Storing Register</a></div>
      <div class="contents-subsubsection"><a href="#ch2-8-3">2.8.3: Backup Memory/Access Authorization Register</a>
      </div>
      <div class="contents-subsubsection"><a href="#ch2-8-4">2.8.4: G/A (μPD65641) Version Checking Register</a></div>
      <div class="contents-subsection"><a href="#ch2-9">2.9: Bitstring Command Device Access Feature</a></div>
      <div class="contents-subsection"><a href="#ch2-10">2.10: Write/Buffer</a></div>
      <div class="contents-subsection"><a href="#ch2-11">2.11: About Controlling the HuC6270 with an Interrupt</a></div>
      <div class="contents-subsubsection"><a href="#ch2-11-1">2.11.1: Before Using the VRAM-VRAM DMA</a></div>
      <div class="contents-subsubsection"><a href="#ch2-11-2">2.11.2: Sample Program for Controlling the HuC6270 with an
          Interrupt</a></div>
    </div>
  </div>

  <div class="chapter" id="ch1">
    <h2>Chapter 1: Introduction</h2>
    <div class="section" id="ch1-1">
      <h3>1.1 PC-FXGA Board Summary</h3>
      <p>The PC-FXGA Board has a V810 CPU and HuC62 chipset, and is made up
        of a basic component containing the DRAM controller on the gate array and the IRQ controller,
        and a debugger support component containing peripheral circuitry, which together
        provides an environment to function as a system.
      </p>
    </div>
    <div class="section" id="ch1-2">
      <h3>1.2 Main Features</h3>
      <table id="table1-2">
        <th>Component</th>
        <th>Containing</th>
        <th>Notes</th>
        <tr>
          <td>MPU</td>
          <td>V810 (μ PD70732)</td>
          <td>21.47727MHz RISC Architecture 32bit MPU</td>
        </tr>
        <tr>
          <td>RCM</td>
          <td>EPROM 1Mbytes</td>
          <td>1PL, Kanji font, etc.</td>
        </tr>
        <tr>
          <td>Main memory</td>
          <td>MRAM 2Mbytes</td>
          <td></td>
        </tr>
        <tr>
          <td>Gate Array</td>
          <td>G/A (μ PD65641)</td>
          <td>TIMER, MMC, IOC, ITC, etc.</td>
        </tr>
        <tr>
          <td rowspan="8">Peripheral Memory</td>
          <td>KRAM 1Mbytes</td>
          <td>For HuC6272</td>
        </tr>
        <tr>
          <td>VRAM A 128Kbytes</td>
          <td>For HuC6270#0</td>
        </tr>
        <tr>
          <td>VRAM B 128Kbytes</td>
          <td>For HuC6270#1</td>
        </tr>
        <tr>
          <td>RRAM 16Kbytes</td>
          <td>For HuC6271</td>
        </tr>
        <tr>
          <td>Display buffer 0 128Kbytes</td>
          <td>For HuC6273</td>
        </tr>
        <tr>
          <td>Display buffer 1 128Kbytes</td>
          <td>For HuC6273</td>
        </tr>
        <tr>
          <td>Z buffer 128Kbytes</td>
          <td>For HuC6273</td>
        </tr>
        <tr>
          <td>Texture buffer 1Mbytes</td>
          <td>For HuC6273</td>
        </tr>
        <tr>
          <td rowspan="6">Peripheral Devices</td>
          <td>HuC6270 x 2</td>
          <td>Video Display/Processor</td>
        </tr>
        <tr>
          <td>HuC6272</td>
          <td>VDP, SCSI, Data Transfer Sequencer</td>
        </tr>
        <tr>
          <td>HuC6271</td>
          <td>Image Dilation Processor</td>
        </tr>
        <tr>
          <td>HuC6261</td>
          <td>Video Color Encoder, Effector</td>
        </tr>
        <tr>
          <td>HuC6230</td>
          <td>Sound Controller</td>
        </tr>
        <tr>
          <td>HuC6273</td>
          <td>3D Processor</td>
        </tr>
      </table>
    </div>
  </div>

  <hr>

  <div class="chapter" id="ch2">
    <h2>Chapter 2: Functional Features</h2>
    <div class="section" id="ch2-1">
      <h3>2.1 Address List (Memory Map)</h3>
      <img src="memorymap.svg">
    </div>
    <div class="section" id="ch2-2">
      <h3>2.2 I/O Access Space</h3>
      <img src="ioaccessspace.svg">
    </div>
    <div class="section" id="ch2-3">
      <h3>2.3 Address List</h3>
      <table id="table2-3">
        <th>Device</th>
        <th>Bus<br>Size</th>
        <th>Register Name</th>
        <th>I/O Access<br>Address</th>
        <th>Memory Access<br>Address</th>
        <th>R/W</th>
        <tr>
          <td rowspan="17">HuC6230</td>
          <td rowspan="17">8</td>
          <td>PSG Channel Select Register<br>IO_SB_CHSEL</td>
          <td>0000_0100</td>
          <td>8000_0100</td>
          <td>W</td>
        </tr>
        <tr>
          <td>PSG Main Sound Adjustment Register<br>IO_SB_MVOL</td>
          <td>0000_0102</td>
          <td>8000_0102</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Frequency Fine Adjustment Register<br>IO_SB_FRQL</td>
          <td>0000_0104</td>
          <td>8000_0104</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Frequency Coarse Adjustment Register<br>IO_SB_FRQH</td>
          <td>0000_0106</td>
          <td>8000_0106</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Channel ON DDA Channel Sound Register<br>IO_SB_CHVOL</td>
          <td>0000_0108</td>
          <td>8000_0108</td>
          <td>W</td>
        </tr>
        <tr>
          <td>L/R Sound Register<br>IO_SB_PAN</td>
          <td>0000_010A</td>
          <td>8000_010A</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Wave Shape Register<br>IO_SB_WAVE</td>
          <td>0000_010C</td>
          <td>8000_010C</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Noise Enable Noise Frequency Register<br>IO_SB_NOISE</td>
          <td>0000_010E</td>
          <td>8000_010E</td>
          <td>W</td>
        </tr>
        <tr>
          <td>LFO Frequency Register<br>IO_SB_LFOFRQ</td>
          <td>0000_0110</td>
          <td>8000_0110</td>
          <td>W</td>
        </tr>
        <tr>
          <td>LFO Control Register<br>IO_SB_LFOCR</td>
          <td>0000_0112</td>
          <td>8000_0112</td>
          <td>W</td>
        </tr>
        <tr>
          <td>ADPCM Reset Sampling Frequency Switch<br>Register&ensp;IO_SB_ADP_CR</td>
          <td>0000_0120</td>
          <td>8000_0120</td>
          <td>W</td>
        </tr>
        <tr>
          <td>ADPCM #0 L Volume Register<br>IO_SB_ADP_VOLL0</td>
          <td>0000_0122</td>
          <td>8000_0122</td>
          <td>W</td>
        </tr>
        <tr>
          <td>ADPCM #0 R Volume Register<br>IO_SB_ADP_VOLR0</td>
          <td>0000_0124</td>
          <td>8000_0124</td>
          <td>W</td>
        </tr>
        <tr>
          <td>ADPCM #1 L Volume Register<br>IO_SB_ADP_VOLL1</td>
          <td>0000_0126</td>
          <td>8000_0126</td>
          <td>W</td>
        </tr>
        <tr>
          <td>ADPCM #1 R Volume Register<br>IO_SB_ADP_VOLR1</td>
          <td>0000_0128</td>
          <td>8000_0128</td>
          <td>W</td>
        </tr>
        <tr>
          <td>PCM L Volume Register<br>IO_SB_PCM_VOLL</td>
          <td>0000_012A</td>
          <td>8000_012A</td>
          <td>W</td>
        </tr>
        <tr>
          <td>PCM R Volume Register<br>IO_SB_PCM_VOLR</td>
          <td>0000_012C</td>
          <td>8000_012C</td>
          <td>W</td>
        </tr>
        <!-- Next page in original doc -->
        <th>Device</th>
        <th>Bus<br>Size</th>
        <th>Register Name</th>
        <th>I/O Access<br>Address</th>
        <th>Memory Access<br>Address</th>
        <th>R/W</th>
        <tr>
          <td rowspan="7">HuC6271</td>
          <td rowspan="7">8</td>
          <td>Horizontal Scroll Register Low<br>IO_RA_SCROLL</td>
          <td>0000_0200</td>
          <td>8000_0200</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Horizontal Scroll Register High<br>IO_RA_SCROLLH</td>
          <td>0000_0202</td>
          <td>8000_0202</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Optional Functionality Setting Register<br>IO_RA_CR</td>
          <td>0000_0204</td>
          <td>8000_0204</td>
          <td>W</td>
        </tr>
        <tr>
          <td>NRL Block YDC Component Register<br>IO_RA_NRLY</td>
          <td>0000_0208</td>
          <td>8000_0208</td>
          <td>W</td>
        </tr>
        <tr>
          <td>NRL Block UDC Component Register<br>IO_RA_NRLU</td>
          <td>0000_020C</td>
          <td>8000_020C</td>
          <td>W</td>
        </tr>
        <tr>
          <td>NRL Block VDC Component Register<br>IO_RA_NRLV</td>
          <td>0000_0210</td>
          <td>8000_0210</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Horizontal Synchronized Adjustment Register<br>IO_RA_HSYNC</td>
          <td>0000_0214</td>
          <td>8000_0214</td>
          <td>W</td>
        </tr>
        <tr>
          <td rowspan="3">HuC6261</td>
          <td rowspan="3">16</td>
          <td>Address Register<br>IO_NT_AR</td>
          <td>0000_0300</td>
          <td>8000_0300</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Status Register<br>IO_NT_SR</td>
          <td>0000_0300</td>
          <td>8000_0300</td>
          <td>R</td>
        </tr>
        <tr>
          <td>Data Register<br>IO_NT_DR</td>
          <td>0000_0304</td>
          <td>8000_0304</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td rowspan="3">HuC6270#0<br>
            <span style="font-size: 12px; border: none;">(Connected
              to<br>HuC6261's VDA<br>[Lower
              part])</span>
          </td>
          <td rowspan="3">16</td>
          <td>Address Register<br>IO_70A_AR</td>
          <td>0000_0400</td>
          <td>8000_0400</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Status Register<br>10_70A_SR</td>
          <td>0000_0400</td>
          <td>8000_0400</td>
          <td>R</td>
        </tr>
        <tr>
          <td>Data Register<br>IO_70B_DR</td>
          <td>0000_0404</td>
          <td>8000_0404</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td rowspan="3">HuC6270#1<br>
            <span style="font-size: 12px; border: none;">(Connected
              to<br>HuC6261's VDB<br>[Upper
              part])</span>
          </td>
          <td rowspan="3">16</td>
          <td>Address Register<br>IO_70B_AR</td>
          <td>0000_0500</td>
          <td>8000_0500</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Status Register<br>IO_70B_SR</td>
          <td>0000_0500</td>
          <td>8000_0500</td>
          <td>R</td>
        </tr>
        <tr>
          <td>Data Register<br>IO_70B_DR</td>
          <td>0000_0501</td>
          <td>8000_0504</td>
          <td>R/W</td>
        </tr>
        <!-- Next page in original doc -->
        <th>Device</th>
        <th>Bus<br>Size</th>
        <th>Register Name</th>
        <th>I/O Access<br>Address</th>
        <th>Memory Access<br>Address</th>
        <th>R/W</th>
        <tr>
          <td rowspan="6">HuC6272</td>
          <td rowspan="6">32<br>(16+<br>16)</td>
          <td>Address Register Low<br>IO_KING_AR</td>
          <td>0000_0600</td>
          <td>8000_0600</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Address Register High<br>IO_KING_AR</td>
          <td>0000_0602</td>
          <td>8000_0602</td>
          <td>W</td>
        </tr>
        <tr>
          <td>Status Register Low<br>IO_KING_SR</td>
          <td>0000_0600</td>
          <td>8000_0600</td>
          <td>R</td>
        </tr>
        <tr>
          <td>Status Register High<br>IO_KING_SRH</td>
          <td>0000_0602</td>
          <td>8000_0602</td>
          <td>R</td>
        </tr>
        <tr>
          <td>Data Register Low<br>IO_KING_DR</td>
          <td>0000_0604</td>
          <td>8000_0604</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Data Register High<br>IO_KING_DRH</td>
          <td>0000_0606</td>
          <td>8000_0606</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>MRAM</td>
          <td>32</td>
          <td>Main Memory</td>
          <td>-</td>
          <td>0000_0000-<br>001F_FFFF</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td rowspan="27">HuC6273</td>
          <td rowspan="27">16</td>
          <td>Command FIFO port</td>
          <td>0050_0000</td>
          <td>8050_0000</td>
          <td>W/O</td>
        </tr>
        <tr>
          <td>Command FIFO port</td>
          <td>0050_0002</td>
          <td>8050_0002</td>
          <td>W/O</td>
        </tr>
        <tr>
          <td>Command FIFO status register</td>
          <td>0050_0000</td>
          <td>8050_0000</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>Command FIFO status register</td>
          <td>0050_0002</td>
          <td>8050_0002</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>Command FIFO control</td>
          <td>0050_0004</td>
          <td>8050_0004</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>CMT bank select register</td>
          <td>0050_0006</td>
          <td>8050_0006</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>CMT start address register</td>
          <td>0050_0008</td>
          <td>8050_0008</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>CMT byte count register</td>
          <td>0050_000A</td>
          <td>8050_000A</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Interrupt mask register</td>
          <td>0050_000C</td>
          <td>8050_000C</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Interrupt clear register</td>
          <td>0050_000E</td>
          <td>8050_000E</td>
          <td>W/O</td>
        </tr>
        <tr>
          <td>Interrupt status register</td>
          <td>0050_0010</td>
          <td>8050_0010</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Read back register</td>
          <td>0050_0012</td>
          <td>8050_0012</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Horizontal timing register</td>
          <td>0050_0014</td>
          <td>8050_0014</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Vertical timing register</td>
          <td>0050_0016</td>
          <td>8050_0016</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>SCT address Hi</td>
          <td>0050_0018</td>
          <td>8050_0018</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Sprite control register</td>
          <td>0050_001A</td>
          <td>8050_001A</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>CD result register 0</td>
          <td>0050_001C</td>
          <td>8050_001C</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>CD result register 1</td>
          <td>0050_001E</td>
          <td>8050_001E</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>SP window clip X left</td>
          <td>0050_0020</td>
          <td>8050_0020</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>SP window clip Y top</td>
          <td>0050_0022</td>
          <td>8050_0022</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>SP window clip X right</td>
          <td>0050_0024</td>
          <td>8050_0024</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>SP window clip Y bottom</td>
          <td>0050_0026</td>
          <td>8050_0026</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Misc. status register</td>
          <td>0050_0028</td>
          <td>8050_0028</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Error status register</td>
          <td>0050_002A</td>
          <td>8050_002A</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>Display control register</td>
          <td>0050_002C</td>
          <td>8050_002C</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Status control register</td>
          <td>0050_002E</td>
          <td>8050_002E</td>
          <td>W/O</td>
        </tr>
        <tr>
          <td>Config register</td>
          <td>0050_002E</td>
          <td>8050_002E</td>
          <td>R/O</td>
        </tr>
        <!-- Next page in original doc -->
        <th>Device</th>
        <th>Bus<br>Size</th>
        <th>Register Name</th>
        <th>I/O Access<br>Address</th>
        <th>Memory Access<br>Address</th>
        <th>R/W</th>
        <tr>
          <td rowspan="28">HuC6273</td>
          <td rowspan="28">16</td>
          <td>TE code control register</td>
          <td>0050_0030</td>
          <td>8050_0030</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>TE code address register</td>
          <td>0050_0032</td>
          <td>8050_0032</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>reserved</td>
          <td>0050_0034</td>
          <td>8050_0034</td>
          <td>---</td>
        </tr>
        <tr>
          <td>reserved</td>
          <td>0050_0036</td>
          <td>8050_0036</td>
          <td>---</td>
        </tr>
        <tr>
          <td>reserved</td>
          <td>0050_0038</td>
          <td>8050_0038</td>
          <td>---</td>
        </tr>
        <tr>
          <td>reserved</td>
          <td>0050_003A</td>
          <td>8050_003A</td>
          <td>---</td>
        </tr>
        <tr>
          <td>Raster hit register</td>
          <td>0050_003C</td>
          <td>8050_003C</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>reserved</td>
          <td>0050_003E</td>
          <td>8050_003E</td>
          <td>---</td>
        </tr>
        <tr>
          <td>PE test register</td>
          <td>0050_0040</td>
          <td>8050_0040</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Memory test register</td>
          <td>0050_0042</td>
          <td>8050_042</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>result register[0]</td>
          <td>0050_0060</td>
          <td>8050_0060</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[1]</td>
          <td>0050_0062</td>
          <td>8050_0062</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[2]</td>
          <td>0050_0064</td>
          <td>8050_0064</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[3]</td>
          <td>0050_0066</td>
          <td>8050_0066</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[4]</td>
          <td>0050_0068</td>
          <td>8050_0068</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[5]</td>
          <td>0050_006A</td>
          <td>8050_006A</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[6]</td>
          <td>0050_006C</td>
          <td>8050_006C</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[7]</td>
          <td>0050_006E</td>
          <td>8050_006E</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[8]</td>
          <td>0050_0070</td>
          <td>8050_0070</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[9]</td>
          <td>0050_0072</td>
          <td>8050_0072</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[10]</td>
          <td>0050_0074</td>
          <td>8050_0074</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[11]</td>
          <td>0050_0076</td>
          <td>8050_0076</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[12]</td>
          <td>0050_0078</td>
          <td>8050_0078</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[13]</td>
          <td>0050_007A</td>
          <td>8050_007A</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[14]</td>
          <td>0050_007C</td>
          <td>8050_007C</td>
          <td>R/O</td>
        </tr>
        <tr>
          <td>result register[15]</td>
          <td>0050_007E</td>
          <td>8050_007E</td>
          <td>R/O*</td>
        </tr>
        <tr>
          <td>Texture map buffer direct access<br>(pack mode)
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>(64K byte space)<div
              style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>Texture map
            buffer direct access<br>(pack mode)
          </td>
          <td>0051_0000<div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>0051_FFFE
          </td>
          <td>8051_0000<div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>8051_FFFE
          </td>
          <td>R/W<div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>R/W
          </td>
        </tr>
        <tr>
          <td>Texture map buffer direct access<br>(unpack mode)<div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>(128Kbyte space)<div
              style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>Texture map direct access<br>(unpack mode)
          </td>
          <td>0052_0000<div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>0052_FFFE
          </td>
          <td>8052_0000<div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>8052_FFFE
          </td>
          <td>R/W<div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>
            <div style="border: none; text-align: center;">.</div>R/W
          </td>
        </tr>
        <tr>
          <td rowspan="3">DBPIO</td>
          <td rowspan="3">8</td>
          <td>Debugger Parallel Port A2=A1=0</td>
          <td>-</td>
          <td>F800_0000</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Debugger Parallel Port A2=0 A1=1</td>
          <td>-</td>
          <td>F800_0002</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>Debugger Parallel Port A1=0 A2=1</td>
          <td>-</td>
          <td>F800_0004</td>
          <td>R/W</td>
        </tr>
        <tr>
          <td>ROM</td>
          <td>16</td>
          <td>Debugger IPL ROM<br>(Image per 1Mbytes)</td>
          <td>-</td>
          <td>FF00_0000-<br>FFFF_FFFF</td>
          <td>R</td>
        </tr>
      </table>
    </div>
    <div class="section" id="ch2-4">
      <h3>2.4 Onboard Register List</h3>
      <table id="table2-4">
        <th>R/W</th>
        <th>I/O and Memory<br>Access Address</th>
        <th>Register Name</th>
        <th>D15</th>
        <th>D14</th>
        <th>D13</th>
        <th>D12</th>
        <th>D11</th>
        <th>D10</th>
        <th>D9</th>
        <th>D8</th>
        <th>D7</th>
        <th>D6</th>
        <th>D5</th>
        <th>D4</th>
        <th>D3</th>
        <th>D2</th>
        <th>D1</th>
        <th>D0</th>
        <tr>
          <td>W</td>
          <td>0000_0000<br>8000_0000</td>
          <td>K Port #0<br>Control Register IO_K0_CR</td>
          <td class="gray-bg" colspan="13"></td>
          <td>IOS</td>
          <td>MOD</td>
          <td>TRG</td>
        </tr>
        <tr>
          <td>R</td>
          <td>0000_0000<br>8000_0000</td>
          <td>K Port #0<br>Status Register IO_K0_SR</td>
          <td class="gray-bg" colspan="12"></td>
          <td>END</td>
          <td>IOS</td>
          <td>MOD</td>
          <td>TRG</td>
        </tr>
        <tr>
          <td>R/W</td>
          <td>0000_0040<br>8000_0040</td>
          <td>K Port #0<br>Data Register Low IO_K0_DATA</td>
          <td colspan="16">KEY DATA D0-D15</td>
        </tr>
        <tr>
          <td>R/W</td>
          <td>0000_0042<br>8000_0042</td>
          <td>K Port #0<br>Data Register High IO_K0_DATA</td>
          <td colspan="16">KEY DATA D16-D31</td>
        </tr>
        <tr>
          <td>W</td>
          <td>0000_0080<br>8000_0080</td>
          <td>K Port #1<br>Control Register IO_K1_CR</td>
          <td class="gray-bg" colspan="13"></td>
          <td>IOS</td>
          <td>MOD</td>
          <td>TRG</td>
        </tr>
        <tr>
          <td>R</td>
          <td>0000_0080<br>8000_0080</td>
          <td>K Port #1<br>Status Register IO_K1_SR</td>
          <td class="gray-bg" colspan="12"></td>
          <td>END</td>
          <td>IOS</td>
          <td>MOD</td>
          <td>TRG</td>
        </tr>
        <tr>
          <td>R/W</td>
          <td>0000_00C0<br>8000_00C0</td>
          <td>K Port #1<br>Data Register Low IO_K1_DATA</td>
          <td colspan="16">KEY DATA D0-D15</td>
        </tr>
        <tr>
          <td>R/W</td>
          <td>0000_00C2<br>8000_00C2</td>
          <td>K Port #1<br>Data Register High IO_K1_DATA</td>
          <td colspan="16">KEY DATA D16-D31</td>
        </tr>
        <tr>
          <td>R/W</td>
          <td>0000_0700<br>8000_0700</td>
          <td>Expansion Bus Reset Register<br>IO_IO_RESET</td>
          <td class="gray-bg" colspan="15"></td>
          <td>ERST</td>
        </tr>
        <tr>
          <td>R</td>
          <td>0000_0C00<br>8000_0C00</td>
          <td>HuC6270#0 Address Storage Register<br>IO_IO_7AR_A</td>
          <td class="gray-bg" colspan="12"></td>
          <td colspan="4">HuC6270#0 AR</td>
        </tr>
        <tr>
          <td>R</td>
          <td>0000_0C40<br>8000_0C40</td>
          <td>HuC6270#1 Address Storage Register<br>IO_IO_7AR_B</td>
          <td class="gray-bg" colspan="12"></td>
          <td colspan="4">HuC6270#1 AR</td>
        </tr>
        <tr>
          <td>R/W</td>
          <td>0000_0C80<br>8000_0C80</td>
          <td>Backup Memory/Access Allowing Register<br>IO_IO_BKUP</td>
          <td class="gray-bg" colspan="14"></td>
          <td>CARD</td>
          <td>BRAM</td>
        </tr>
        <tr>
          <td>R</td>
          <td>0000_0CC0<br>8000_0CC0</td>
          <td>μ PD65641 Version Checking Register<br>IO_IO_VERSION</td>
          <td class="gray-bg" colspan="12"></td>
          <td colspan="4">Version No.</td>
        </tr>
        <tr>
          <td>W</td>
          <td>0000_0E00<br>8000_0E00</td>
          <td>Address Error Clear Register<br>IO_ADRERR_CLR</td>
          <td colspan="16">D0-D15=(dummy) AERR Clear</td>
        </tr>
        <tr>
          <td>R</td>
          <td>0000_0E00<br>8000_0E00</td>
          <td>Interrupt Status Register<br>IO_IRQ_STAT</td>
          <td class="gray-bg" colspan="8"></td>
          <td>AER</td>
          <td>TMI</td>
          <td>INT(<br>Extra)</td>
          <td>INTKR</td>
          <td>INT7A</td>
          <td>INT72</td>
          <td>INT7B</td>
          <td>INT73</td>
        </tr>
        <tr>
          <td>R/W</td>
          <td>0000_0E40<br>8000_0E40</td>
          <td>Interrupt Mask Register<br>IO_IRQ_MASK</td>
          <td class="gray-bg" colspan="8"></td>
          <td>AER</td>
          <td>TMI</td>
          <td>INT(<br>Extra)</td>
          <td>INTKR</td>
          <td>INT7A</td>
          <td>INT72</td>
          <td>INT7B</td>
          <td>INT73</td>
        </tr>
        <tr>
          <td>R/W</td>
          <td>0000_0E80<br>8000_0E80</td>
          <td>Interrupt Level Setting Register 0<br>IO_IRQ_LEVELL</td>
          <td class="gray-bg" colspan="4"></td>
          <td colspan="3">INT7A</td>
          <td colspan="3">INT72</td>
          <td colspan="3">INT7B</td>
          <td colspan="3">INT73</td>
        </tr>
        <tr>
          <td>R/W</td>
          <td>0000_0EC0<br>8000_0EC0</td>
          <td>Interrupt Level Setting Register 1<br>IO_IRQ_LEVELH</td>
          <td class="gray-bg" colspan="7"></td>
          <td colspan="3">INTTM</td>
          <td colspan="3">INTEX</td>
          <td colspan="3">INTKP</td>
        </tr>
        <tr>
          <td>R/W</td>
          <td>0000_0F00<br>8000_0F00</td>
          <td>Timer Control/Condition Register<br>IO_TIMER_TCR</td>
          <td class="gray-bg" colspan="13"></td>
          <td>TIREQ</td>
          <td>TEN</td>
          <td>TIEN</td>
        </tr>
        <tr>
          <td>R/W</td>
          <td>0000_0F80<br>8000_0F00</td>
          <td>Timer Initialization Register<br>IO_TIMER_TMR</td>
          <td colspan="16">TIMER Value</td>
        </tr>
        <tr>
          <td>R</td>
          <td>0000_0FC0<br>8000_0FC0</td>
          <td>Timer Down Counter<br>IO_TIMER_DWC</td>
          <td colspan="16">TIMER Value</td>
        </tr>
      </table>
    </div>
    <div class="section" id="ch2-5">
      <h3>2.5 Keypad Interface</h3>
      <p>Interface to the standard pad, etc.</p>
      <p>It has 2 independent ports, and different kinds of devices can be attached to each. Input/output data is 32
        bits with a 4-bit signature set per device, allowing for determining the connected device.</p>
      <h4>Register Structure</h4>
      <ol>
        <li>K Port Control Register (IO_K0_CR/IO_K1_CR)
          <p>The K port control register is a register for making transfer requests to the pad and other devices
            connected to the port.<br>
            Simultaneously, it specifies things including the input/output direction, resetting tap selector, etc.</p>
          <table class="table2-5">
            <th>R/W</th>
            <th>I/O and Memory<br>Access Address</th>
            <th>Register Name</th>
            <th>D15</th>
            <th>D14</th>
            <th>D13</th>
            <th>D12</th>
            <th>D11</th>
            <th>D10</th>
            <th>D9</th>
            <th>D8</th>
            <th>D7</th>
            <th>D6</th>
            <th>D5</th>
            <th>D4</th>
            <th>D3</th>
            <th>D2</th>
            <th>D1</th>
            <th>D0</th>
            <tr>
              <td>W</td>
              <td>0000_0000<br>8000_0000</td>
              <td>K Port #0 Control Register<br>IO_K0_CR</td>
              <td class="gray-bg" colspan="13"></td>
              <td>IOS</td>
              <td>MOD</td>
              <td>TRG</td>
            </tr>
            <tr>
              <td>W</td>
              <td>0000_0080<br>8000_0080</td>
              <td>K Port #1 Control Register<br>IO_K1_CR</td>
              <td class="gray-bg" colspan="13"></td>
              <td>IOS</td>
              <td>MOD</td>
              <td>TRG</td>
            </tr>
          </table>
        </li>
        <br>
        <li>K Port Status Register (IO_K0_SR/IO_K1_SR)
          <p>The K port status register is a register to read out the transfer status.</p>
          <table class="table2-5">
            <th>R/W</th>
            <th>I/O and Memory<br>Access Address</th>
            <th>Register Name</th>
            <th>D15</th>
            <th>D14</th>
            <th>D13</th>
            <th>D12</th>
            <th>D11</th>
            <th>D10</th>
            <th>D9</th>
            <th>D8</th>
            <th>D7</th>
            <th>D6</th>
            <th>D5</th>
            <th>D4</th>
            <th>D3</th>
            <th>D2</th>
            <th>D1</th>
            <th>D0</th>
            <tr>
              <td>R</td>
              <td>0000_0000<br>8000_0000</td>
              <td>K Port #0 Status Register<br>IO_K0_SR</td>
              <td class="gray-bg" colspan="12"></td>
              <td>END</td>
              <td>IOS</td>
              <td>MOD</td>
              <td>TRG</td>
            </tr>
            <tr>
              <td>R</td>
              <td>0000_0080<br>8000_0080</td>
              <td>K Port #1 Status Register<br>IO_K1_SR</td>
              <td class="gray-bg" colspan="12"></td>
              <td>END</td>
              <td>IOS</td>
              <td>MOD</td>
              <td>TRG</td>
            </tr>
          </table>
          <br>
          <ol type="a">
            <li>TRG (BIT_K_TRG)<br>
              <span style="margin-left:40px;">Transfer Request Bit. Write 1 to begin transfer. Cleared when transfer
                ends.</span>
            </li><br>
            <li>MOD (BIT_K_MOD)<br>
              <span style="margin-left:40px;">When transferring with this bit set, the clear signal is set to
                tap.</span>
            </li><br>
            <li>IOS (BIT_K_IOS)<br>
              <span style="margin-left:40px;">When transferring, when this bit is set it accepts input, when it is
                cleared, it sends output.</span>
            </li><br>
            <li>END (BIT_K_END)<br>
              <span style="margin-left:40px;">Bit that signifies the transfer has finished.</span><br>
              <span style="margin-left:40px;">Normally, when a transfer finishes, a K port transfer finished interrupt
                is raised, but when
                reading from K port data register, this bit is cleared at the same time the interrupt is cleared.
              </span>
            </li>
          </ol>
          <p>Note: The control register can be written to only when the TRG and END bits of the status register are 0.
          </p>
        </li>
        <li>K Port Data Register Low (IO_K0_DL/IO_K1_DL)<br>
          <p>Register for reading/writing the lower 16 bits of the K port input/output.</p>
          <p>Reading out clears both the K port transfer finish interrupt and the K port status register's END bit.</p>
          <table class="table2-5">
            <th>R/W</th>
            <th>I/O and Memory<br>Access Address</th>
            <th>Register Name</th>
            <th>D15</th>
            <th>D14</th>
            <th>D13</th>
            <th>D12</th>
            <th>D11</th>
            <th>D10</th>
            <th>D9</th>
            <th>D8</th>
            <th>D7</th>
            <th>D6</th>
            <th>D5</th>
            <th>D4</th>
            <th>D3</th>
            <th>D2</th>
            <th>D1</th>
            <th>D0</th>
            <tr>
              <td>R/W</td>
              <td>0000_0040<br>8000_0040</td>
              <td>K Port #0 Data Register Low<br>IO_K0_DATA</td>
              <td colspan="16">KEY DATA D0-D15</td>
            </tr>
            <tr>
              <td>R/W</td>
              <td>0000_00C0<br>8000_00C0</td>
              <td>K Port #1 Data Register Low<br>IO_K1_DATA</td>
              <td colspan="16">KEY DATA D0-D15</td>
            </tr>
          </table>
        </li>
        <br>
        <li>K Port Data Register High (IO_K0_DH/IO_K1_DH)<br>
          <p>Register for reading/writing the upper 16 bits of the K port input/output.</p>
          <table class="table2-5">
            <th>R/W</th>
            <th>I/O and Memory<br>Access Address</th>
            <th>Register Name</th>
            <th>D15</th>
            <th>D14</th>
            <th>D13</th>
            <th>D12</th>
            <th>D11</th>
            <th>D10</th>
            <th>D9</th>
            <th>D8</th>
            <th>D7</th>
            <th>D6</th>
            <th>D5</th>
            <th>D4</th>
            <th>D3</th>
            <th>D2</th>
            <th>D1</th>
            <th>D0</th>
            <tr>
              <td>R/W</td>
              <td>0000_0042<br>8000_0042</td>
              <td>K Port #0 Data Register High<br>IO_K0_DATA_DH</td>
              <td colspan="16">KEY DATA D16-D31</td>
            </tr>
            <tr>
              <td>R/W</td>
              <td>0000_00C2<br>8000_00C2</td>
              <td>K Port #1 Data Register High<br>IO_K1_DATA_DH</td>
              <td colspan="16">KEY DATA D16-D31</td>
            </tr>
          </table>
          <p>Note: The data register can only be read/written when the status register's TRG bit is 0.</p>
        </li>
      </ol>
      <h4>Content of Transfer Data</h4>
      <p>Bit D31-D28 of the data contains the device signature, allowing for determination of the device.</p>
      <ol>
        <li>Standard pad (signature is 15)
          <table class="table2-5b">
            <tr>
              <td>Bit #</td>
              <td>D15</td>
              <td>D14</td>
              <td>D13</td>
              <td>D12</td>
              <td>D11</td>
              <td>D10</td>
              <td>D9</td>
              <td>D8</td>
              <td>D7</td>
              <td>D6</td>
              <td>D5</td>
              <td>D4</td>
              <td>D3</td>
              <td>D2</td>
              <td>D1</td>
              <td>D0</td>
            </tr>
            <tr>
              <td>Contents</td>
              <td>0</td>
              <td>SW2</td>
              <td>0</td>
              <td>SW1</td>
              <td>←</td>
              <td>↓</td>
              <td>→</td>
              <td>↑</td>
              <td>Run</td>
              <td>Sel</td>
              <td>VI</td>
              <td>V</td>
              <td>IV</td>
              <td>III</td>
              <td>II</td>
              <td>I</td>
            </tr>
            <tr>
              <td>Bit #</td>
              <td>D31</td>
              <td>D30</td>
              <td>D29</td>
              <td>D28</td>
              <td>D27</td>
              <td>D26</td>
              <td>D25</td>
              <td>D24</td>
              <td>D23</td>
              <td>D22</td>
              <td>D21</td>
              <td>D20</td>
              <td>D19</td>
              <td>D18</td>
              <td>D17</td>
              <td>D16</td>
            </tr>
            <tr>
              <td>Contents</td>
              <td>1</td>
              <td>1</td>
              <td>1</td>
              <td>1</td>
              <td class="gray-bg" colspan="12"></td>
            </tr>
          </table>
          The shaded region indicates indefinite values.
        </li>
        <br>
        <li>Mouse (signature is 13)
          <table class="table2-5b">
            <tr>
              <td>Bit #</td>
              <td>D15</td>
              <td>D14</td>
              <td>D13</td>
              <td>D12</td>
              <td>D11</td>
              <td>D10</td>
              <td>D9</td>
              <td>D8</td>
              <td>D7</td>
              <td>D6</td>
              <td>D5</td>
              <td>D4</td>
              <td>D3</td>
              <td>D2</td>
              <td>D1</td>
              <td>D0</td>
            </tr>
            <tr>
              <td>Contents</td>
              <td>X7</td>
              <td>X6</td>
              <td>X5</td>
              <td>X4</td>
              <td>X3</td>
              <td>X2</td>
              <td>X1</td>
              <td>X0</td>
              <td>Y7</td>
              <td>Y6</td>
              <td>Y5</td>
              <td>Y4</td>
              <td>Y3</td>
              <td>Y2</td>
              <td>Y1</td>
              <td>Y0</td>
            </tr>
            <tr>
              <td>Bit #</td>
              <td>D31</td>
              <td>D30</td>
              <td>D29</td>
              <td>D28</td>
              <td>D27</td>
              <td>D26</td>
              <td>D25</td>
              <td>D24</td>
              <td>D23</td>
              <td>D22</td>
              <td>D21</td>
              <td>D20</td>
              <td>D19</td>
              <td>D18</td>
              <td>D17</td>
              <td>D16</td>
            </tr>
            <tr>
              <td>Contents</td>
              <td>1</td>
              <td>1</td>
              <td>0</td>
              <td>1</td>
              <td class="gray-bg" colspan="10"></td>
              <td>SW R</td>
              <td>SW L</td>
            </tr>
          </table>
          The shaded region indicates indefinite values.<br>
          <p>SW-L, SW-R Logic: "1" means the switch is pressed, "0" is default</p>
          <p>Mouse movement directions: right is +X, left is -X, down is +Y, up is -Y</p>
          <p>Counter Range: The range of the mouse's internal counter is as follows (for both X and Y direction):</p>
          <table class="table2-5c">
            <tr>
              <td>Count</td>
              <td>Under</td>
              <td>-127</td>
              <td>~</td>
              <td>-1</td>
              <td>0</td>
              <td>+1</td>
              <td>~</td>
              <td>+127</td>
              <td>Over</td>
            </tr>
            <tr>
              <td>Data</td>
              <td>81</td>
              <td>81</td>
              <td>~</td>
              <td>FF</td>
              <td>00</td>
              <td>01</td>
              <td>~</td>
              <td>7F</td>
              <td>7F</td>
            </tr>
          </table>
        </li>
        <br>
        <li>Multitap (signature is 14)
          <table class="table2-5b">
            <tr>
              <td>Bit #</td>
              <td>D15</td>
              <td>D14</td>
              <td>D13</td>
              <td>D12</td>
              <td>D11</td>
              <td>D10</td>
              <td>D9</td>
              <td>D8</td>
              <td>D7</td>
              <td>D6</td>
              <td>D5</td>
              <td>D4</td>
              <td>D3</td>
              <td>D2</td>
              <td>D1</td>
              <td>D0</td>
            </tr>
            <tr>
              <td>Contents</td>
              <td class="gray-bg" colspan="16"></td>
            </tr>
            <tr>
              <td>Bit #</td>
              <td>D31</td>
              <td>D30</td>
              <td>D29</td>
              <td>D28</td>
              <td>D27</td>
              <td>D26</td>
              <td>D25</td>
              <td>D24</td>
              <td>D23</td>
              <td>D22</td>
              <td>D21</td>
              <td>D20</td>
              <td>D19</td>
              <td>D18</td>
              <td>D17</td>
              <td>D16</td>
            </tr>
            <tr>
              <td>Contents</td>
              <td>1</td>
              <td>1</td>
              <td>1</td>
              <td>0</td>
              <td class="gray-bg" colspan="12"></td>
            </tr>
          </table>
          The shaded region indicates indefinite values.
          <br>
          <p>The first transfer is done with the multiltap clear mode on, and each transfer after that is done with the
            multitap clear mode off.<br>
            For a tap that can connect up to 4 devices per multitap, the 5th read returns the above multitap signature
            ($Exxxxxxx)</p>
          <p>Limitations:</p>
          <ol>
            <li>Always perform multitap clear whenever reading/writing data for software
              that doesn't support the multitap.
            </li>
            <li>Always read the signature of the multitap when reading/writing for software
              that does support the multitap (applies to all multitaps made for the PC-FX)
            </li>
          </ol>
        </li>
      </ol>
    </div>
    <div class="section" id="ch2-6">
      <h3>2.6 Timer</h3>
      <p>Has a 16 bit down counter, where each count is 1/30 of a system
        clock cycle (42.95454MHz), so is 1.431818MHz. It can cause an interrupt in
        intervals of approximately 698ns to 46ms.
      </p>
      <h4>Register Structure</h4>
      <ol>
        <li>Timer Control/Condition Register (IO_TIMER_TCR)<br>
          This register controls the timer<br>
          <table class="table2-5">
            <th>R/W</th>
            <th>I/O and Memory<br>Access Address</th>
            <th>Register Name</th>
            <th>D15</th>
            <th>D14</th>
            <th>D13</th>
            <th>D12</th>
            <th>D11</th>
            <th>D10</th>
            <th>D9</th>
            <th>D8</th>
            <th>D7</th>
            <th>D6</th>
            <th>D5</th>
            <th>D4</th>
            <th>D3</th>
            <th>D2</th>
            <th>D1</th>
            <th>D0</th>
            <tr>
              <td>R/W</td>
              <td>0000_0F00<br>8000_0F00</td>
              <td>Timer Control/Condition Register<br>IO_TIMER_TCR</td>
              <td colspan="13" class="gray-bg"></td>
              <td>TIREQ</td>
              <td>TEN</td>
              <td>TIEN</td>
            </tr>
          </table>
          <br>
          <ol type="a">
            <li>TIEN<br>
              <span style="margin-left:40px;">Timer Interrupt Allowing Bit</span><br>
              <span style="margin-left:40px;">If this bit is set to 1, whenever TIREQ becomes 1, it creates a timer
                interrupt.
                The initial value on reset is 0, and in this case interrupt does not happen.</span>
            </li>
            <li>TEN<br>
              <span style="margin-left:40px;">Timer Count Allowing Bit</span><br>
              <span style="margin-left:40px;">
                If this bit is set to 1, the timer counts down.<br>
                Changing this bit from 0 to 1 sets the timer down counter to the value in the
                timer initialization register, and begins counting down.
              </span>
            </li>
            <li>TIREQ<br>
              <span style="margin-left:40px;">Timer Interrupt Request Bit</span><br>
              <span style="margin-left:40px;">Is set to 1 when a borrow occurs in the timer countdown.
                Clear this bit to clear the timer interrupt.</span>
            </li>
          </ol>
          <br>
          <span style="margin-left:80px;">Note: A timer interrupt can be caused by setting all of TIEN,TEN,TIREQ to
            1.</span>
        </li>
        <br>
        <li>Timer Initialization Register (IO_TIMER_TMR)<br>
          Sets the timer's count. However, writing 0 instantly causes a borrow,
          so do not do that.<br>
          <table class="table2-5">
            <th>R/W</th>
            <th>I/O and Memory<br>Access Address</th>
            <th>Register Name</th>
            <th>D15</th>
            <th>D14</th>
            <th>D13</th>
            <th>D12</th>
            <th>D11</th>
            <th>D10</th>
            <th>D9</th>
            <th>D8</th>
            <th>D7</th>
            <th>D6</th>
            <th>D5</th>
            <th>D4</th>
            <th>D3</th>
            <th>D2</th>
            <th>D1</th>
            <th>D0</th>
            <tr>
              <td>R/W</td>
              <td>0000_0F80<br>8000_0F80</td>
              <td>Timer Initialization Register<br>IO_TIMER_TMR</td>
              <td colspan="16">TIMER Value</td>
            </tr>
          </table>
        </li>
        <br>
        <li>Timer Down Counter (IO_TIMER_DWC)<br>
          The down counter. Counts down when the timer control/condition register's TEN bit is set to 1.
          When a borrow occurs as a result of down count, a count is loaded from the
          timer initialization register and counting continues.<br>
          Note: the output frequency is -1 count or +0 count (it will not shift in the +1 direction)<br>
          <table class="table2-5">
            <th>R/W</th>
            <th>I/O and Memory<br>Access Address</th>
            <th>Register Name</th>
            <th>D15</th>
            <th>D14</th>
            <th>D13</th>
            <th>D12</th>
            <th>D11</th>
            <th>D10</th>
            <th>D9</th>
            <th>D8</th>
            <th>D7</th>
            <th>D6</th>
            <th>D5</th>
            <th>D4</th>
            <th>D3</th>
            <th>D2</th>
            <th>D1</th>
            <th>D0</th>
            <tr>
              <td>R/W</td>
              <td>0000_0FC0<br>8000_0FC0</td>
              <td>Timer Down Counter<br>IO_TIMER_DWC</td>
              <td colspan="16">TIMER Value</td>
            </tr>
          </table>
        </li>
      </ol>
    </div>
    <div class="section" id="ch2-7">
      <h3>2.7 Interrupt Controller</h3>
      <p>Receives interrupts from peripheral IC chips and the timer, and can
        change the mask or level.</p>
      <h4>Register Structure</h4>
      <ol>
        <li>Address Error Clear Register (IO_ADRERR_CLR)<br>
          Writing to this register allows for clearing the address error interrupt.<br>
          <table class="table2-5">
            <th>R/W</th>
            <th>I/O and Memory<br>Access Address</th>
            <th>Register Name</th>
            <th>D15</th>
            <th>D14</th>
            <th>D13</th>
            <th>D12</th>
            <th>D11</th>
            <th>D10</th>
            <th>D9</th>
            <th>D8</th>
            <th>D7</th>
            <th>D6</th>
            <th>D5</th>
            <th>D4</th>
            <th>D3</th>
            <th>D2</th>
            <th>D1</th>
            <th>D0</th>
            <tr>
              <td>W</td>
              <td>0000_0E00<br>8000_0E00</td>
              <td>Address Error Clear Register<br>IO_ADRERR_CLR</td>
              <td colspan="16">D0-D15=(dummy) AERR Clear</td>
            </tr>
          </table>
          Note: Address error is an interrupt when the V810 finds that the alignment
          of an address in a load, store, or I/O command is invalid.
        </li>
        <br>
        <li>Interrupt Status Register (IO_IRQ_STAT)<br>
          The status of each interrupt signal at the time of reading can be checked.
          When each signal is active, the bit is set to 1.<br>
          <table class="table2-5">
            <th>R/W</th>
            <th>I/O and Memory<br>Access Address</th>
            <th>Register Name</th>
            <th>D15</th>
            <th>D14</th>
            <th>D13</th>
            <th>D12</th>
            <th>D11</th>
            <th>D10</th>
            <th>D9</th>
            <th>D8</th>
            <th>D7</th>
            <th>D6</th>
            <th>D5</th>
            <th>D4</th>
            <th>D3</th>
            <th>D2</th>
            <th>D1</th>
            <th>D0</th>
            <tr>
              <td>R/W</td>
              <td>0000_0E00<br>8000_0E00</td>
              <td>Interrupt Status Register<br>IO_IRQ_STAT</td>
              <td colspan="8" class="gray-bg"></td>
              <td>AER</td>
              <td>TMI</td>
              <td>INTEX</td>
              <td>INTKP</td>
              <td>INT7A</td>
              <td>INT72</td>
              <td>INT7B</td>
              <td>INT73</td>
            </tr>
          </table>
        </li>
        <br>
        <li>Interrupt Mask Register (IO_IRQ_MASK)<br>
          Can mask interrupts generated by each interrupt signal. To allow interrupts,
          the bit corresponding to the signal must be cleared with a 0. The initialization
          after reset masks everything. Even if an interrupt is masked, the interrupt status
          register will still reflect it.
          <table class="table2-5">
            <th>R/W</th>
            <th>I/O and Memory<br>Access Address</th>
            <th>Register Name</th>
            <th>D15</th>
            <th>D14</th>
            <th>D13</th>
            <th>D12</th>
            <th>D11</th>
            <th>D10</th>
            <th>D9</th>
            <th>D8</th>
            <th>D7</th>
            <th>D6</th>
            <th>D5</th>
            <th>D4</th>
            <th>D3</th>
            <th>D2</th>
            <th>D1</th>
            <th>D0</th>
            <tr>
              <td>R/W</td>
              <td>0000_0E40<br>8000_0E40</td>
              <td>Interrupt Mask Register<br>IO_IRQ_MASK</td>
              <td colspan="9" class="gray-bg"></td>
              <td>TMI</td>
              <td>INTEX</td>
              <td>INTKP</td>
              <td>INT7A</td>
              <td>INT72</td>
              <td>INT7B</td>
              <td>INT73</td>
            </tr>
          </table>
        </li>
        <br>
        <li>Interrupt Level Setting Register 0 (IO_IRQ_LEVELL)<br>
          <table class="table2-5">
            <th>R/W</th>
            <th>I/O and Memory<br>Access Address</th>
            <th>Register Name</th>
            <th>D15</th>
            <th>D14</th>
            <th>D13</th>
            <th>D12</th>
            <th>D11</th>
            <th>D10</th>
            <th>D9</th>
            <th>D8</th>
            <th>D7</th>
            <th>D6</th>
            <th>D5</th>
            <th>D4</th>
            <th>D3</th>
            <th>D2</th>
            <th>D1</th>
            <th>D0</th>
            <tr>
              <td>R/W</td>
              <td>0000_0E80<br>8000_0E80</td>
              <td>Interrupt Level Setting Register 0<br>IO_IRQ_LEVELL</td>
              <td colspan="4" class="gray-bg"></td>
              <td colspan="3">INT7A</td>
              <td colspan="3">INT72</td>
              <td colspan="3">INT7B</td>
              <td colspan="3">INT73</td>
            </tr>
          </table>
        </li>
        <br>
        <li>Interrupt Level Setting Register 1 (IO_IRQ_LEVELH)<br>
          <table class="table2-5">
            <th>R/W</th>
            <th>I/O and Memory<br>Access Address</th>
            <th>Register Name</th>
            <th>D15</th>
            <th>D14</th>
            <th>D13</th>
            <th>D12</th>
            <th>D11</th>
            <th>D10</th>
            <th>D9</th>
            <th>D8</th>
            <th>D7</th>
            <th>D6</th>
            <th>D5</th>
            <th>D4</th>
            <th>D3</th>
            <th>D2</th>
            <th>D1</th>
            <th>D0</th>
            <tr>
              <td>R/W</td>
              <td>0000_0EC0<br>8000_0EC0</td>
              <td>Interrupt Level Setting Register 1<br>IO_IRQ_LEVELH</td>
              <td colspan="7" class="gray-bg"></td>
              <td colspan="3">INTTM</td>
              <td colspan="3">INTEX</td>
              <td colspan="3">INTKP</td>
            </tr>
          </table>
        </li>
        <br>
        The interruprt level of each value is as follows:
        <table class="table2-5c">
          <th>Interrupt Level</th>
          <th>Level Value</th>
          <tr>
            <td>INT F</td>
            <td>7</td>
          </tr>
          <tr>
            <td>INT E</td>
            <td>6</td>
          </tr>
          <tr>
            <td>INT D</td>
            <td>5</td>
          </tr>
          <tr>
            <td>INT C</td>
            <td>4</td>
          </tr>
          <tr>
            <td>INT B</td>
            <td>3</td>
          </tr>
          <tr>
            <td>INT A</td>
            <td>2</td>
          </tr>
          <tr>
            <td>INT 9</td>
            <td>1</td>
          </tr>
          <tr>
            <td>INT 8</td>
            <td>0</td>
          </tr>
        </table>
        <br>
        Note: The interrupt levels cannot be changed unless every interrupt is masked
        in the interrupt mask register.<br><br>
        The initial value after resent is as follows:
        <table class="table2-5c">
          <th>Interrupt Level</th>
          <th>Level Value</th>
          <tr>
            <td>INT 73</td>
            <td>7</td>
          </tr>
          <tr>
            <td>INT 7B</td>
            <td>6</td>
          </tr>
          <tr>
            <td>INT 72</td>
            <td>5</td>
          </tr>
          <tr>
            <td>INT 7A</td>
            <td>4</td>
          </tr>
          <tr>
            <td>INT KP</td>
            <td>3</td>
          </tr>
          <tr>
            <td>INT EX</td>
            <td>2</td>
          </tr>
          <tr>
            <td>INT TM</td>
            <td>1</td>
          </tr>
          <tr>
            <td>INT 8</td>
            <td>0</td>
          </tr>
        </table>
        <br>
        Note: The interrupt levels cannot be changed unless every interrupt is masked
        in the interrupt mask register.
      </ol>
    </div>
    <div class="section" id="ch2-8">
      <h3>2.8 Function of Other Onboard Registers</h3>
      <div class="subsection" id="ch2-8-1">
        <h4>2.8.1 Expansion Bus Reset Register (IO_IO_RESET)</h4>
        <p>Provides a reset signal for the expansion bus and the backup memory expansion bus.</p>
        <table class="table2-5">
          <th>R/W</th>
          <th>I/O and Memory<br>Access Address</th>
          <th>Register Name</th>
          <th>D15</th>
          <th>D14</th>
          <th>D13</th>
          <th>D12</th>
          <th>D11</th>
          <th>D10</th>
          <th>D9</th>
          <th>D8</th>
          <th>D7</th>
          <th>D6</th>
          <th>D5</th>
          <th>D4</th>
          <th>D3</th>
          <th>D2</th>
          <th>D1</th>
          <th>D0</th>
          <tr>
            <td>R/W</td>
            <td>0000_0700<br>8000_0700</td>
            <td>Expansion Bus Reset Register<br>IO_IO_RESET</td>
            <td colspan="14" class="gray-bg"></td>
            <td>ERST</td>
          </tr>
        </table>
        <ol type="a">
          <li>ERST<br>
            <span style="margin-left:40px;">Expansion Bus Reset</span><br>
            <span style="margin-left:40px;">If this bit is set to 1, the reset signal for the expansion
              bus and the backup memory bup can be enabled. To reset the device connected to the bus,
              this bit must be set to 1 for the duration needed to reset the device.</span>
          </li>
        </ol>
      </div>
      <div class="subsection" id="ch2-8-2">
        <h4>2.8.2 HuC6270 Address Storing Register</h4>
        <p>Register that saves what was last written to the AR of each HuC6270. The contents of this register
          are evacuated at the start of an interrupt, and written into the AR of each HuC6270 at the end of the
          interrupt
          to increase the possibilities related to HuC6270 device access in both interrupt and regular times.
          However, the HuC6270's internal registers, such as the VRAM write address, cannot be evacuated, so caution is
          necessary.
        </p>
        <ul>
          <li>HuC6270#0 Address Storing Register<br>
            Can read the contents of the last write access to HuC6270#0's AR
            <table class="table2-5">
              <th>R/W</th>
              <th>I/O and Memory<br>Access Address</th>
              <th>Register Name</th>
              <th>D15</th>
              <th>D14</th>
              <th>D13</th>
              <th>D12</th>
              <th>D11</th>
              <th>D10</th>
              <th>D9</th>
              <th>D8</th>
              <th>D7</th>
              <th>D6</th>
              <th>D5</th>
              <th>D4</th>
              <th>D3</th>
              <th>D2</th>
              <th>D1</th>
              <th>D0</th>
              <tr>
                <td>R</td>
                <td>0000_0C00<br>8000_0C00</td>
                <td>HuC6270#0 Address Saving Register<br>IO_IO_7AR_A</td>
                <td colspan="12" class="gray-bg"></td>
                <td colspan="4">HuC6270#0 AR</td>
              </tr>
            </table>
          </li>
          <li>HuC6270#1 Address Storing Register<br>
            Can read the contents of the last write access to HuC6270#1's AR
            <table class="table2-5">
              <th>R/W</th>
              <th>I/O and Memory<br>Access Address</th>
              <th>Register Name</th>
              <th>D15</th>
              <th>D14</th>
              <th>D13</th>
              <th>D12</th>
              <th>D11</th>
              <th>D10</th>
              <th>D9</th>
              <th>D8</th>
              <th>D7</th>
              <th>D6</th>
              <th>D5</th>
              <th>D4</th>
              <th>D3</th>
              <th>D2</th>
              <th>D1</th>
              <th>D0</th>
              <tr>
                <td>R</td>
                <td>0000_0C40<br>8000_0C40</td>
                <td>HuC6270#1 Address Saving Register<br>IO_IO_7AR_B</td>
                <td colspan="12" class="gray-bg"></td>
                <td colspan="4">HuC6270#1 AR</td>
              </tr>
            </table>
          </li>
        </ul>
      </div>
      <div class="subsection" id="ch2-8-3">
        <h4>2.8.3 Backup Memory/Access Allowing Register (IO_IO_BKUP)</h4>
        <table class="table2-5">
          <th>R/W</th>
          <th>I/O and Memory<br>Access Address</th>
          <th>Register Name</th>
          <th>D15</th>
          <th>D14</th>
          <th>D13</th>
          <th>D12</th>
          <th>D11</th>
          <th>D10</th>
          <th>D9</th>
          <th>D8</th>
          <th>D7</th>
          <th>D6</th>
          <th>D5</th>
          <th>D4</th>
          <th>D3</th>
          <th>D2</th>
          <th>D1</th>
          <th>D0</th>
          <tr>
            <td>R/W</td>
            <td>0000_0C80<br>8000_0C80</td>
            <td>Backup Memory/Access Allowing Register<br>IO_IO_BKUP</td>
            <td colspan="14" class="gray-bg"></td>
            <td>CARD</td>
            <td>BRAM</td>
          </tr>
        </table>
        <ol type="a">
          <li>BRAM<br>
            <span style="margin-left:40px;">Internal Backup Memory Access Bit</span><br>
            <span style="margin-left:40px;">Setting this bit to 1 allows reading from and writing to the internal backup
              memory. The initial value on reset is 0.</span>
          </li>
          <li>CARD<br>
            <span style="margin-left:40px;">External Backup Memory Access Bit</span><br>
            <span style="margin-left:40px;">Setting this bit to 1 allows reading from and writing to the external backup
              memory. The initial value on reset is 0.</span>
          </li>
        </ol>
      </div>
      <div class="subsection" id="ch2-8-4">
        <h4>2.8.4 G/A(μPD65641) Version Checking Register</h4>
        <p>Can output the G/A version number.</p>
        <table class="table2-5">
          <th>R/W</th>
          <th>I/O and Memory<br>Access Address</th>
          <th>Register Name</th>
          <th>D15</th>
          <th>D14</th>
          <th>D13</th>
          <th>D12</th>
          <th>D11</th>
          <th>D10</th>
          <th>D9</th>
          <th>D8</th>
          <th>D7</th>
          <th>D6</th>
          <th>D5</th>
          <th>D4</th>
          <th>D3</th>
          <th>D2</th>
          <th>D1</th>
          <th>D0</th>
          <tr>
            <td>R</td>
            <td>0000_0CC0<br>8000_0CC0</td>
            <td>μ PD65641 Version Checking Register<br>IO_IO_VERSION</td>
            <td colspan="12" class="gray-bg"></td>
            <td>Version No.</td>
          </tr>
        </table>
      </div>
    </div>
    <div class="section" id="ch2-9">
      <h3>2.9 Bitstring Command Device Access Features</h3>
      <p>By accessing each device's memory access address using the V810 MPU's bitstring transfer command, etc.,
        one can transfer blocks.
        This functionality only performs reading/writing from a device, so it is necessary
        to set addresses beforehand.
      </p>
      <p style="margin: auto 40px;">[Example: Writing to HuC6270#0's VRAM]</p>
      <ol>
        <li>Set MAWR in HuC6270#0's AR</li>
        <li>Set the address in HuC6270#0's DR</li>
        <li>Set VWR in HuC6270#0's AR</li>
        <li>On the V810, set zero to r26,r27; transfer byte count×16 to r28;
          $A400_0000, HuC6270#0's memory access address to r29; the address of
          the data to be transferred to r30
        </li>
        <li>Execute the MOVBS command</li>
      </ol>
      <p>The expected transfer may fail if an interrupt occurs during the transfer and
        changes the device settings.
      </p>
      <p style="margin-left:40px;">Warnings about the V810 bitstring command:</p>
      <ul>
        <li>In the bitstring command, if the data to be written is not at a word boundary,
          up to three extra bytes will be written to the destination. The extra bytes will try to
          write the original values.
        </li>
        <li>In the bitstring command, if the data to be read is not at a word boundary,
          up to three bytes of a read cycle begins.
        </li>
      </ul>
    </div>
    <div class="section" id="ch2-10">
      <h3>2.10 Write Buffer</h3>
      <p>Write access for normal I/O takes 6 cycles, but since there is 1 layer that
        corresponds to each of HuC6230, HuC6261, HuC6270, HuC6271, HuC6272, if you try to
        get write access to one of the devices while the buffer is empty, the CPU is
        released with a 0WAIT (2 cycles).
      </p>
    </div>
    <div class="section" id="ch2-11">
      <h3>2.11 About Controlling HuC6270 Interrupts</h3>
      <p>For background sprite display and scroll position settings, changing the settings
        changes it on the spot, and becomes active starting from the next raster display.
        Therefore, if you want it to be effective starting from the next frame instead of the next raster display,
        set these values while the vertical blank interval interrupt is being processed.
      </p>
      <p>To access HuC6270 in the interrupt handler, it is important to
        save the value of HuC6270's AR register at the start and recover the value
        at the end.
      </p>
      <p>Use the address storing register in the HuC6270 to save/recover the value of the AR register
        in the interrupt handler.
      </p>
      <p>The HuC6270 Address Storing Register is a register that constantly holds the value written to to the AR
        register,
        and is read-only.
        There are two registers, IO_IO_7AR_A, IO_IO_7AR_B for HuC6270#0 and HuC6270#1 respectively.
      </p>
      <p>The value written to the AR register and the value that can be read from the address storing register
        is as follows
      </p>
      <table class="table2-11">
        <tr>
          <th>Value Written to HuC6270's AR Register</th>
          <th>Value in the HuC6270's Address Storing Register</th>
        </tr>
        <tr>
          <td>_70_MAWR $00 Memory Write</td>
          <td>$00</td>
        </tr>
        <tr>
          <td>_70_MARR $01 Memory Address Read</td>
          <td>$01</td>
        </tr>
        <tr>
          <td>_70_VWR $02 VRAM Data Write</td>
          <td>$02</td>
        </tr>
        <tr>
          <td>_70_VRR $02 VRAM Data Read</td>
          <td>$02</td>
        </tr>
        <tr>
          <td>_70_CR $05 Control</td>
          <td>$05</td>
        </tr>
        <tr>
          <td>_70_RCR $06 Raster Detection</td>
          <td>$06</td>
        </tr>
        <tr>
          <td>_70_BXR $07 BGX Scroll</td>
          <td>$07</td>
        </tr>
        <tr>
          <td>_70_BYR $08 BGY Scroll</td>
          <td>$08</td>
        </tr>
        <tr>
          <td>_70_MWR $09 Memory Width</td>
          <td>$09</td>
        </tr>
        <tr>
          <td>_70_HSR $0a Horizontal Sync</td>
          <td>$0a</td>
        </tr>
        <tr>
          <td>_70_HDR $0b Horizontal Display</td>
          <td>$0b</td>
        </tr>
        <tr>
          <td>_70_VPR $0c Vertical Sync</td>
          <td>$0c</td>
        </tr>
        <tr>
          <td>_70_VDW $0d Vertical Display</td>
          <td>$0d</td>
        </tr>
        <tr>
          <td>_70_VCR $0e Vertical Display End Position</td>
          <td>$0e</td>
        </tr>
        <tr>
          <td>_70_DCR $0f DMA Control</td>
          <td>$0f</td>
        </tr>
        <tr>
          <td>_70_SOUR $10 DMA Source Address</td>
          <td>Varies (See Note 1)</td>
        </tr>
        <tr>
          <td>_70_DESR $11 DMA Destination</td>
          <td>Varies (See Note 1)</td>
        </tr>
        <tr>
          <td>_70_LENR $12 DMA Block Size</td>
          <td>Varies (See Note 1)</td>
        </tr>
        <tr>
          <td>_70_DVSSR $13 DMA VRAM-SATB Source</td>
          <td>$03 (See Note 2)</td>
        </tr>
      </table>
      <p>Note 1: VRAM-VRAM DMA is only effective in burst mode, and is only used in special circumstances.
        Therefore, the HuC6270 Address Storing Register does not support registers related to
        VRAM-VRAM DMA. When using VRAM-VRAM DMA, read the next section, <a href="#ch2-11-1">Before Using the
          VRAM-VRAM-DMA</a>
      </p>
      <p>Note 2: If _70_DVSSR($13) is written to the AR register, the value in the address storing
        register will be #03. This is because it is impossible to write $03 to the AR register, so
        $03 is used as the value the corresponds to _70_DVSSR.
        Therefore, if the value read from the address storing register was $03, the value
        to write back to the AR register is $13, not $03.
      </p>
      <div class="subsection" id="ch2-11-1">
        <h4>2.11.1 Before Using the VRAM-VRAM DMA</h4>
        <p>When controlling HuC6260 using the HuC6270 address storage register, the register
          does not support VRAM-VRAM DMA-related registers. So, when accessing VRAM-VRAM DMA
          related registers, special care must be taken.
          Access the VRAM-VRAM DMA-related registers, _70_SOUR, _70_DESR, _70_LENR,
          in no interrupt mode.
        </p>
        <p>Below is an example of accessing VRAM-VRAM DMA-related registers.</p>
        <div class="codeblock">; Sample program using the HuC6270's VRAM-VRAM DMA to control the HuC6270
;
    include c62dev.sh
    include v93.sh
    include sup.sh
;
    ,text
;
    public set_70_dma_sour
    public set_70_dma_desr
    public set_70_dma_lenr
;
;---------------------------------------------
; Setting the DMA transfer source VRAM address
; void set_70_dma_sour(u_short dma_sour, int devno)
; ra0: u_short dma_sour DMA transfer source VRAM address
; ra1: int devno choice between HuC6270 #0, #1
;
set_70_dma_sour:
        mov.w #_70_SOUR,at
        jr set_70_dma
;---------------------------------------------
; Setting the DMA transfer destination VRAM address
; void set_70_dma_desr(u_short dma_desr, int devno)
; ra0: u_short dma_desr DMA transfer destination VRAM address
; ra1: int devno choice between HuC6270 #0, #1
;
set_70_dma_desr:
        mov.w #_70_DESR,at
        jr set_70_dma
;---------------------------------------------
; Setting the DMA transfer block length and starting the transfer (turns on the transfer trigger)
; void set_70_dma_lenr(u_short dma_lenr, int devno)
; ra0: u_short dma_desr DMA transfer block length1
; ra1: int devno choice between HuC6270 #0, #1        
;
set_70_dma_lenr:
        mov.w #_70_LENR,at
;
set_70_dma:
        mov.w #IO_70A,rg0
        cmp zero,ra1
        beq set_70_dma_0
        mov.w #IO_70B,rg0
set_70_dma_0:
        stsr psw,rg1        ; Initial status of whether the IRQ is restricted/allowed
        ori #$1000,rg1,rg2
        ldsr rg2,psw        ; IRQ note allowed
        out.h at,DEV_70_AR(rg0)
        out.h ra0,DEV_70_DR(rg0)
        ldsr rg1,psw        ; Restore status of whether IRQ is restricted/allowed
        rts
;
;=========================================================================</div>
      </div>
      <div class="subsection" id="ch2-11-2">
        <h4>2.11.2 Sample Program for Controlling the HuC6270 with an Interrupt</h4>
        <p>
          Below is a sample program that uses an interrupt to control the HuC6270.
        </p>
        <p>Please note that when using the library function sat_trans_trg(), you must also
          use an interrupt handler like the sample program below.
        </p>
        <div class="codeblock">/* Typical Interruprt Configuration Sample Program */

#include&lt;v93.h&gt;

/* Declaring each interrupt's entry address */
extern void _dint0(void);
extern void _dint1(void);
extern void _dint2(void);
extern void _dint3(void);

/* Declaring interrupt-related subroutines */
extern void irq_on(void);
extern void disp_mode(int mode);
extern void irq_wait(void);

/* Disable CPU Interrupt */
irq_disable();

/* Setting the interrupt mask for the interrupt controller and priority
   Setting the interrupt entry address to each interrupt vector address */
set_irq_mask(0x7f);
set_irq_vector(&_dint0, IRQ_LEVELF);  /* KING  */
set_irq_prio(IRQ_PRIOF, IRQ_KING);
set_irq_vector(&_dint1, IRQ_LEVELE);  /* 70B   */
set_irq_prio(IRQ_PRIOE, IRQ_70B);
set_irq_vector(&_dint2, IRQ_LEVELD);  /* 70A   */
set_irq_prio(IRQ_PRIOD, IRQ_70A);
set_irq_vector(&int_pad, IRQ_LEVELB);  /* KP    */
set_irq_prio(IRQ_PRIOB, IRQ_KP);
set_irq_vector(&_dint3, IRQ_LEVEL9);  /* TIMER */
set_irq_prio(IRQ_PRIO9, IRQ_TIMER);

/* Reset the interrupt mask for the interrupt controller
   (Interrupt masks that will not be used do not have to be rest) */
reset_irq_mask(BIT_IRQM_7B | BIT_IRQM_7A | BIT_IRQM_KP | BIT_IRQM_KING);

/* Reset and configure HuC6270 */
disp_mode(1);   /* HuC6270 Display On Mode */
irq_on();       /* Turn on HuC6270 vertical blank interval interrupt */
irq_enable();   /* Allow CPU interrupt */
irq_wait();     /* Wait for the next HuC6270 blank interval */



; Typical HuC6270 Vertical Blank Interval Interrupt Handler Sample Program
;
    include c62dev.sh
    include v93.sh
    include sup.sh
;
    ,text
;
    public    _dint1
    public    _dint2
    public    irq_on
    public    disp_mode
    public    irq_wait
    public    cpu_irq_enable
;
; Declaring a struct for storing the scroll coordinates
;
sup_ds    struct
m_bxr0     ds     2
m_bxr1     ds     2
m_byr0     ds     2
m_byr1     ds     2
        align   4
        ends
;
;
;---------------------------------------------
; HuC6270#0 Interrupt Address
_dint2:
; HuC6270#1 Interrupt Address
_dint1:
;
; Saving all registers
    addi  #-(4*4),sp,sp
    st.w  link,0*4(sp)
    stsr  eipc,link
    st.w  link,1*4(sp)
    stsr  eipsw,link
    st.w  link,2*4(sp)
    st.w  at,3*4(sp)
    push  ra0-rg9,ut
;
; Call interrupt handler
    jal   vblank_irq
;
; Restor all registers
    pop  ra0-rg9,ut
    ld.w  3*4(sp),at
    ld.w  2*4(sp),link
    ldsr  link,eipsw
    ld.w  1*4(sp),link
    ldsr  link,eipc
    ld.w  0*4(sp),link
    addi  #4*4,sp,sp
    reti
;

;---------------------------------------------

; VBLANK Interval Interrupt Handler for HuC6270 #0, #1
vblank_irq:
          push  link
;
; Dummy read the status of the HuC6270 #1
          in.h        IO_70B_SR,zero
;
; Saving HuC6270 #0, #1 address registers
          in.h        IO_IO_7AR_A,rg0
          andi        #$0f,rg0,rg0
          st.h        rg0,ar70_a(zero)
          in.h        IO_IO_7AR_B,rg0
          andi        #$0f,rg0,rg0
          st.h        rg0,ar70_b(zero)
;
; If the interrupt happened during the display interval, don't handle it
; (The interrupt source is not the start of the VBLANK interval)
          in.h        IO_70A_SR,rg0
          andi        #$20,rg0,rg0    ;Check VBLANK bit
          jeq         vblank_irq_skip
;
; Manipulate HuC6270 #0,#1 based on the whether display is on/off
          mov         #disp_f,rg9
          ld.w        (rg9),rg0
          cmp         #0,rg0
          bne         irq_disp_on
;
; On display off mode, hide background, sprites
          move        #_70_CR,rg0
          out.h       rg0,IO_70A_AR
          out.h       rg0,IO_70B_AR
          ld.h        m_70_reg+cr70+_70a_(zero),rg0
          ld.h        m_70_reg+cr70+_70b_(zero),rg1
          andi        #~$c0,rg0,rg0     ;reset SB BB bit
          andi        #~$c0,rg0,rg1     ;reset SB BB bit
          st.h        rg0,m_70_reg+cr70+_70a_(zero)
          st.h        rg1,m_70_reg+cr70+_70b_(zero)
          out.h       rg0,IO_70A_DR
          out.h       rg1,IO_70B_DR
          jl          vblank_irq_end
;
; On display on mode, make background, sprites visible
irq_disp_on:
          mov         #_70_CR,rg0
          out.h       rg0,IO_70A_AR
          out.h       rg0,IO_70B_AR
          ld.h        m_70_reg+cr70+_70a_(zero),rg0
          ld.h        m_70_reg+cr70+_70b_(zero),rg1
          ori         #$c0,rg0,rg0     ;set SB BB bit
          ori         #$c0,rg0,rg1     ;set SB BB bit
          st.h        rg0,m_70_reg+cr70+_70a_(zero)
          st.h        rg1,m_70_reg+cr70+_70b_(zero)
          out.h       rg0,IO_70A_DR
          out.h       rg1,IO_70B_DR
;
; If display is on, manipulate the background scroll register
;set scroll
          mov         #sup_scrol,rg8
          mov         #_70_BXR,rg0
          out.h       rg0,IO_70A_AR
          out.h       rg0,IO_70B_AR
          ld.h        m_bxr0(rg8),rg0
          ld.h        m_bxr1(rg8),rg1
          out.h       rg0,IO_70A_DR
          out.h       rg1,IO_70B_DR

          mov         #_70_BYR,rg0
          out.h       rg0,IO_70A_AR
          out.h       rg0,IO_70B_AR
          ld.h        m_byr0(rg8),rg0
          ld.h        m_byr1(rg8),rg1
          out.h       rg0,IO_70A_DR
          out.h       rg1,IO_70B_DR
;
; Update the interrupt counter
vblank_irq_end:
          mov         #irq_count,rg8
          ld.h        (rg8),rg0
          add         #1,rg0
          st.h        rg0,(rg8)
;
; Restore address registers of HuC6270 #0,#1
          ld.h        ar70_a(zero),rg0
          cmp         #3,rg0
          bne         vblank_ar70a_ok
          mov         #$13,rg0
vblank_ar70a_ok:
          out.h       rg0,IO_70A_AR
          ld.h        ar70_b(zero),rg1
          cmp         #3,rg1
          bne         vblank_ar70b_ok
          mov         #$13,rg1
vblank_ar70b_ok:
          out.h       rg1,IO)70B_AR
;
; End interrupt handling
vblank_irq_skip:
          pop         link
          rts
;
;------------------------------------------------------------------- 
; Allow the VBLANK interval start interrupt for HuC6270#0
;void irq_on();
irq_on:
          ld.h        m_70_reg+cr70+_70a_(zero),rg0
          ori         #8,rg0,rg0    ;v-blank irq on
          st.h        rg0,m_70_reg+cr70+_70a_(zero)
          mov         #_70_CR,rg2
          out.h       rg2,IO_70A_AR
          out.h       rg0,IO_70A_DR
          in.h        IO_70A_SR,zero  ;dummy read
          in.h        IO_70B_SR,zero  ;dummy read
          in.h        IO_KING_SR,zero ;dummy read
          rts
;-----------------------------------------------------------------------
; Wait for a VBLANK interrupt
;void irq_wait(void);
irq_wait:
          mov         #irq_count,rg1                                   
          ld.h        (rg1),rg0                                        
irq_wait_l:                                                                  
          ld.h        (rg1),rg2                                        
          cmp         rg0,rg2                                          
          beq         irq_wait_l                                       
          rts                                                         
;---------------------------------------------------------------------------
; Set HuC6270 #0,#1 display mode
; If display is off, wait until the next VBLANK, and don't restore until display is turned off
;void disp_mode(int mode);
;   mode  DISP_OFF 0
;         DIP_ON  not 0
disp_mode:
          mov         #disp_f,rg1
          st.b        ra0,(rg1)                                        
          cmp         #0,ra0                                           
          beq         irq_wait                                         
          rts
;=========================================================================
          .data
;
          public      irq_count
          public      sup_scrol
;
          align       4
;
; Work to save display mode
disp_f      dw      0
;
; Work to save the background scroll position
sup_scrol   ds      sup_ds
;
          align       2
;
; Work to save the interrupt counter
irq_count   dh      0
;
;---------------------------------------------------------------------
          seg       zseg
          align     2
;
; Work to save the HuC6270 address register on interrupt
ar70_a      dh      0
ar70_b      dh      0
        </div>
      </div>
    </div>
  </div>
  <hr>
  Copyright and Trademark Notice
  <ul>
    <li>This document is a part of the PC-FXGA Software Development Kit. Please do not
      use this for any other purpose than PC-FX/PC-FXGA software development
    </li>
    <li>
      Hudson Soft bears no responsibility for any direct or indirect damage caused by
      the use of this document.
    </li>
    <li>
      Hudson Soft does not directly answer questions about how the contents of this document,
      or other questions. Please do not contact Hudson Soft.</li>
    <li>
      When using this document, read the “Conditions for the use of this Software”.
    </li>
    <li>Hudson Soft holds the copyright for this document.</li>
  </ul>

  <div class="footer">(C) 1995 HUDSON SOFT</div>

</body>

</html>